<!DOCTYPE html>
<html>

<head>
      <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Begin Jekyll SEO tag v -->



<meta name="generator" content="Jekyll v4.3.2" />





<meta property="og:locale" content="" />

  <link rel="shortcut icon" type="image/png" href="/webdataconnector/assets/logo.png">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
  <link rel="stylesheet" href="/webdataconnector/assets/css/main.css">
  <link rel="stylesheet" href="/webdataconnector/assets/css/github-highlight.css">

  <script src="/webdataconnector/assets/js/redirect-to-search.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>



	<script type="text/javascript">
        var search_blob = {
		
            
                "/webdataconnector/404.html": {
                    "title": null,
                    "content": "404 Page not found :( The requested page could not be found."
                },
            
		
            
                "/webdataconnector/about/": {
                    "title": "About",
                    "content": "This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at jekyllrb.com You can find the source code for Minima at GitHub: jekyll / minima You can find the source code for Jekyll at GitHub: jekyll / jekyll"
                },
            
		
            
                "/webdataconnector/docs/api_ref.html": {
                    "title": "WDC API Reference",
                    "content": "WebDataConnectorAPI ColumnInfo aggType alias columnRole columnType dataType description filterable foreignKey geoRole id numberFormat unitsFormat DataDoneCallback InitCallback SchemaCallback ShutdownCallback StandardConnection alias tables joins Table incrementValue tableInfo appendRows TableInfo columns alias description id joinOnly WebDataConnector getData getSchema init shutdown tableau authPurpose authType connectionData connectionName locale password phase platformBuildNumber platformEdition platformOs platformVersion username version abortForAuth abortWithError enableCookiePersistence log makeConnector registerConnector reportProgress submit aggTypeEnum avg count count_dist median sum authPurposeEnum enduring ephemeral authTypeEnum basic custom none columnRoleEnum dimension measure columnTypeEnum continuous discrete dataTypeEnum bool date datetime float geometry int string geographicRoleEnum area_code cbsa_msa city congressional_district country_region county state_province zip_code_postcode localeEnum america brazil china france germany japan korea spain numberFormatEnum currency number percentage scientific phaseEnum authPhase gatherDataPhase interactivePhase unitsFormatEnum billions_english billions_standard millions thousands WebDataConnectorAPI WebDataConnectorAPI: This API Reference contains all of the functions and objects for the WDC API version 2. WDC version 1 is no longer supported. ColumnInfo ColumnInfo: Represents metadata about a column in a table. aggType aggType: aggTypeEnum (Optional) The default aggregation type for this column. alias alias: string (Optional) The user friendly alias of this column. If this property is omitted, the column id will be used. columnRole columnRole: columnRoleEnum (Optional) The default role of this column: dimension or measure. columnType columnType: columnTypeEnum (Optional) The default type of this column: discrete or continuous. dataType dataType: dataTypeEnum The data type of this column. description description: string (Optional) A description of the column. This description is added to the metadata for the column and is saved when you save the workbook. You can view the column metadata in the Simulator. filterable filterable: bool (Optional) Whether the column should be used as the join filtering column in the dependent table. For more information, see Join Filtering. Note: This feature is only supported in version 2.2 and later of the WDC. foreignKey foreignKey: Object (Optional) An object that specifies the table ID and column ID to use in join filtering to create the primary to foreign key relationship. Set this property on the column used in the dependent table (the foreign key) and point to the table ID and column ID of the primary table (the primary key). For more information, see Join Filtering. Note: This feature is only supported in version 2.2 and later of the WDC. For example, you might enter a foreign key object like this: foreignKey: { \"tableId\": \"users\", \"columnId\": \"id\" } geoRole geoRole: geographicRoleEnum (Optional) The default geographic role of this column. id id: string The id of this column. Column ids must be unique within a table. The id can only contain alphanumeric (a-z, A-Z, 0-9) and underscore characters (_). The id must match the regular expression: \"^[a-zA-Z0-9_]\\*$\". numberFormat numberFormat: numberFormatEnum (Optional) The default number formatting for this column. unitsFormat unitsFormat: unitsFormatEnum (Optional) The default units formatting for this column. DataDoneCallback __call(): void Callback function to tell Tableau that the connector has finished gathering data. Returns void InitCallback __call(): void Callback function to tell Tableau the connector&#39;s init method has finished. Returns void SchemaCallback __call(tables: Array&lt;TableInfo&gt;, connections: Array&lt;StandardConnection&gt;): void Callback function for reporting the tables this WDC contains. tables is a list of all tables in the connection and is required. Parameters tables: Array&lt;TableInfo&gt; connections: Array&lt;StandardConnection&gt; Returns void ShutdownCallback __call(): void Callback function to tell Tableau the connector&#39;s shutdown method has finished. Returns void StandardConnection StandardConnection: The metadata for standard connections, or predefined joins. Note: This feature is only supported in version 2.1 and later of the WDC. alias alias: string An alias for the standard connection. This is the name of the connection that is displayed in Tableau Desktop. tables tables: array Specifies the tables that you want to join. The table properties must match the properties defined in the table schema. id. The table ID. alias. An alias for the table. \"tables\": [{ \"id\": \"The table id\", \"alias\": \"The table alias\" }, { \"id\": \"The table id\", \"alias\": \"The table alias\" }] joins joins: array An array of join objects which specifies which objects to join and with which join type. Each join object takes the following form: \"joins\": [{ \"left\": { \"tableAlias\": \"The alias for the table\", \"columnId\": \"The id for the column\" }, \"right\": { \"tableAlias\": \"The alias for the table\", \"columnId\": \"The id for the column\" }, \"joinType\": \"The join type, either 'inner' or 'left'\" }] Example var standardConnection = { \"alias\": \"Joined earthquake data\", \"tables\": [{ \"id\": \"magPlace\", \"alias\": \"Magnitude and Place\" }, { \"id\": \"timeUrl\", \"alias\": \"Time and URL\" }], \"joins\": [{ \"left\": { \"tableAlias\": \"Magnitude and Place\", \"columnId\": \"id\" }, \"right\": { \"tableAlias\": \"Time and URL\", \"columnId\": \"id\" }, \"joinType\": \"inner\" }] }; Table Table: Object which is used to actually append data when creating an extract. incrementValue incrementValue: string If this is an incremental refresh and the table supports incremental refreshes, this property will contain the largest value from the incrementColumn in the current extract. This value will be an empty string otherwise. See Incremental Refresh for details. &nbsp; tableInfo tableInfo: TableInfo The metadata about this table appendRows appendRows(rows: Array&lt;Array&lt;any&gt;&gt;): any Called to actually append rows of data to the extract and is called in the getData function during the Gather Data Phase. Takes either an array of arrays or an array of objects which contain the actual rows of data for the extract. The format for these match version 1 of the API. Parameters rows: Array&lt;Array&lt;any&gt;&gt; Returns any Example To avoid overwhelming the data pipeline, which currently has a 128MB limit per function call, you can create a while loop for the appendRows function. This is important if you are working with very large data sets. The following code uses a size variable along with the row_index to add rows of data in size increments. Each row in the table is assigned an index value, represented by the row_index value. It is a best practice to also call the reportProgress function as you add data so that Tableau can report the progress to end-users during the extract creation process. In this example, 1000 rows are added at a time. If you are working with a large data set, you might want to choose a larger size to improve performance. Each append operation needs to be under the 128MB data limit. var row_index = 0; var size = 1000; while (row_index &lt; tableData.length){ table.appendRows(tableData.slice(row_index, size + row_index)); row_index += size; tableau.reportProgress(\"Getting row: \" + row_index); } TableInfo TableInfo: Represents metadata about a table of data columns columns: Array&lt;ColumnInfo&gt; An array of columns that belong to this table. alias alias: string (Optional) An alias for this table to be shown to the user. This alias is editable by the user and must be unique across all tables used in a join. If this property is omitted, the table id will be used. description description: string (Optional) A user friendly description of the contents in this table. id id: string A unique id for this particular table. The id can only contain alphanumeric (a-z, A-Z, 0-9) and underscore characters (_). The id must match the regular expression: \"^[a-zA-Z0-9_]\\*$\". Note: May not contain certain characters such as a hyphen. incrementColumnId incrementColumnId: string (Optional) The id of the column which can be used for incremental refreshes. Must be an int, date, or datetime column. See Incremental Refresh for details. joinOnly joinOnly: bool (Optional) Whether you want to make join filtering required for this table. If you set this value to true, you cannot connect to the table without first connecting to the other table. Join Filtering for details. WebDataConnector WebDataConnector: This is the actual interface a WDC will be asked to implement. init and shutdown are optional and will be filled in automatically if a connector does not implement these. getData getData(table: Table, doneCallback: DataDoneCallback): void Called to create or update the data for a particular instance of this WDC. data is returned for each table in the connection. Once all data has been returned, the connector must call doneCallback to indicate that data gathering has finished. Parameters table: Table doneCallback: DataDoneCallback Callback function to indicate data gathering is completed. Returns void getSchema getSchema(schemaCallback: SchemaCallback): void Called to retrieve the schema information for this WDC. Parameters schemaCallback: SchemaCallback Called to inform Tableau about the schema. Returns void init init(initCallback: InitCallback): void Called first in each phase of the web data connector. See WDC Lifecycle and Phases for details. @param initCallback - Called to inform Tableau when the connector has finished initializing. Parameters initCallback: InitCallback Returns void shutdown shutdown(shutdownCallback: ShutdownCallback): void Called at the end of each phase of the web data connector. See WDC Lifecycle and Phases for details. @param shutdownCallback - Called to inform Tableau when the connector has finished shutdown. Parameters shutdownCallback: ShutdownCallback Returns void tableau tableau: The tableau object represents state and functionality of the Tableau product. authPurpose authPurpose: authPurposeEnum Current context of auth. See WDC Authentication for details. &nbsp; authType authType: authTypeEnum Current type of authentication for this connector. connectionData connectionData: String A string that you can use to store data between phases. For example, you might store user input that you want to use in the getData phase. Note that this string is saved as plain text, so you should not use connectionData to store sensitive information. For passwords or authentication tokens, use the password property. To store and retrieve JavaScript objects with the connectionData property, that is to serialize and deserialize objects, use JSON.stringify and JSON.parse. connectionName connectionName: String Name of this connection. locale locale: localeEnum Current locale, or locale with most similar language, of the web data connector user password password: Object You can use this property to store a password, OAuth authentication token, or other secret. This property can be a JSON object and is not written to disk. phase phase: phaseEnum Current phase of the web data connector. platformBuildNumber platformBuildNumber: String The build number for Tableau Desktop. Note: This feature is only supported in version 2.1 and later of the WDC. For example, you might see a build number like this: 10100.16.1005.2001 platformEdition platformEdition: String The edition of Tableau Desktop. Note: This feature is only supported in version 2.1 and later of the WDC. Either pro, standard, or public. platformOs platformOs: String The operating system on which Tableau Destkop is installed. Note: This feature is only supported in version 2.1 and later of the WDC. Either win for Windows or mac for MacOS. platformVersion platformVersion: String The version of Tableau Desktop. Note: This feature is only supported in version 2.1 and later of the WDC. Tableau uses semantic versioning, which means that the version matches the following syntax: major.minor.patch For example, you might see the following version: 10.1.0 username username: String Username tied to data source, persisted in a .twb, .twbx, etc. version version: String Current version of the Web Data Connector API abortForAuth abortForAuth(errorMessage: string): void Called whenever the connector has invalid credentials and needs to reauthenticate its user. This method must be called from the init method during the gather data phase. Parameters errorMessage: string message which only shows up in logs and on Tableau Server. Returns void abortWithError abortWithError(errorMessage: string): void Throws an error within Tableau with the passed errorMessage Parameters errorMessage: string message to display to the user in Tableau. Returns void enableCookiePersistence enableCookiePersistence(): void Enables cookie persistence in the current Tableau Desktop session. Cookies generated in any WDC will be made available to all WDC connections in a given Tableau Desktop session after this function is called. Once enabled, this behavior will remain in effect until Tableau Desktop is closed. This does not have an effect on WDC extract refreshes in Tableau Server. Returns void log log(logMessage: string): void Logs a message in the Tableau log system Parameters logMessage: string Returns void makeConnector makeConnector(): WebDataConnector Returns a new instance of a WebDataConnector. Returns WebDataConnector registerConnector registerConnector(connector: WebDataConnector): void Registers your connector with Tableau. You call this function after you have created the connector instance and attached functions to the instance. Parameters connector: WebDataConnector Returns void reportProgress reportProgress(progressMessage: string): void Displays a progress message to the user while an extract is being created. For example, if you switch from the Data Source pane to a sheet, a dialog appears that displays the progress message. Note that this progress message is intended to inform Tableau Desktop users. Tableau Server users will not see the message, and calling this method with a very high frequency could adversely affect performance. Note: This feature is only supported in version 2.1 and later of the WDC. Parameters progressMessage: string Returns void Example In the getData function of your connector, you iterate over the rows in a table where each row has an index value assigned to a variable called row_index. You use the following code to display a progress message after every 100 rows: if (row_index % 100 === 0) { tableau.reportProgress(\"Getting row: \" + row_index); } submit submit(): void Tells Tableau that the connector has finished the interactive phase or the authentication phase. After this method is called, Tableau proceeds to the gather data phase. Returns void aggTypeEnum aggTypeEnum: This enum represents the default aggregation that can optionally be assigned as metadata for columns of the int and float dataType. avg avg: count count: count_dist count_dist: median median: sum sum: authPurposeEnum authPurposeEnum: This enum represents the context in which authentication is being requested. See WDC Authentication for details. &nbsp; enduring enduring: Indicates that the WDC running in the context of Tableau Server. ephemeral ephemeral: Indicates that the WDC is running in the context of Tableau Desktop. authTypeEnum authTypeEnum: This enum represents the authentication type of the web data connector. See WDC Authentication for details. &nbsp; basic basic: custom custom: none none: columnRoleEnum columnRoleEnum: This enum represents the default role of a column. dimension dimension: measure measure: columnTypeEnum columnTypeEnum: This enum represents the default type of a column. continuous continuous: discrete discrete: dataTypeEnum dataTypeEnum: This Enum represents the different data types available to each column bool bool: date date: datetime datetime: float float: geometry geometry: int int: string string: geographicRoleEnum geographicRoleEnum: This enum represents the default geographic role that can be assigned to a column. area_code area_code: cbsa_msa cbsa_msa: city city: congressional_district congressional_district: country_region country_region: county county: state_province state_province: zip_code_postcode zip_code_postcode: localeEnum localeEnum: This enum represents the locale, or the locale with the most similar language, of the of the web data connector user. america en-us: brazil pt-br: china zh-cn: france fr-fr: germany de-de: japan ja-jp: korea ko-kr: spain es-es: numberFormatEnum numberFormatEnum: This enum represents the default number format that can optionally be assigned as metadata for columns of the int and float dataType. currency currency: number number: percentage percentage: scientific scientific: phaseEnum phaseEnum: This enum represents the different phases in which a web data connector can be run. See WDC Lifecycle and Phases for details. &nbsp; authPhase authPhase: gatherDataPhase gatherDataPhase: interactivePhase interactivePhase: unitsFormatEnum unitsFormatEnum: This enum represents the default unit format that can optionally be assigned as metadata for columns of the int and float dataType. billions_english billions_english: billions_standard billions_standard: millions millions: thousands thousands: Legend Enumeration Enumeration member Interface Property Method Generated using TypeDoc"
                },
            
		
            
		
            
                "/webdataconnector/wdc2-site/": {
                    "title": null,
                    "content": ""
                },
            
		
            
                "/webdataconnector/community/": {
                    "title": "Community Portal",
                    "content": "The following connectors have been written by the Tableau Community and made available to use. If you write a connector, please contribute! Important: These connectors are not written by or supported by Tableau. If you encounter an issue with one of the connectors here, please reach out to the developer."
                },
            
		
            
		
            
                "/webdataconnector/docs/": {
                    "title": "Get Started",
                    "content": "Create a Web Data Connector (WDC) when you want to connect to a web data source from Tableau. A WDC is an HTML page with JavaScript code that connects to web data (for example, by means of a REST API), converts the data to a JSON format, and passes the data to Tableau. Note: This site is for version 2.x of the WDC API, which is compatible only with Tableau 10.0 and later. Version 1 of the WDC API, used with earlier versions of Tableau, is no longer supported. Upgrading from WDC version 1.x If you have connectors that were created using WDC version 1.x, those connectors might not work in later versions of Tableau. If you want your connector to work in later versions of Tableau, or if you want to use the features available in version 2.x of the WDC, you will need to update the connector. For information about updating your connectors, see Upgrading from WDC Version 1.x. For information about version compatibility, see WDC Versions. This section will guide you through the process of setting up your development environment and running the sample WDCs in the simulator. Confirm prerequisites Get the WDC SDK Run the simulator Try the sample WDCs Confirm prerequisites You’re going to need a couple of things before we get started. Make sure you have the following dependencies installed: Git node and npm Get the WDC SDK Open a terminal in the directory where you want to download the WDC SDK. Then run the following command to clone the WDC git repository: git clone https://github.com/tableau/webdataconnector.git Change to the directory where you downloaded the repository: cd webdataconnector Run the simulator Install dependencies with npm: npm install --production Note: You must run the command with administrator or sudo privileges. Start the test web server: npm start Open a browser and navigate to the following URL: http://localhost:8888/Simulator/index.html The WDC simulator appears. Note: The npm start command also starts a test proxy server on port 8889 that you can route requests through in order to circumvent Cross Origin Resource Sharing (CORS) restrictions. For more information, see Working with CORS. Try the sample WDCs In the WDC URL field, confirm that the URL is set to the sample USGS Earthquake Data connector: ../Examples/html/earthquakeUSGS.html Alternatively, look in the Examples directory for more sample connectors. Click the Start Interactive Phase button to display the user interface for the earthquake WDC. Click the Get Earthquake Data button. Click the Fetch Table Data button to download the data and display it in a table. Ready to make your own connector? Jump to the WDC Tutorial."
                },
            
		
            
                "/webdataconnector/docs/search.html": {
                    "title": "Search",
                    "content": ""
                },
            
		
            
                "/webdataconnector/docs/wdc_about.html": {
                    "title": "About Tableau Help",
                    "content": "Addressing Implicit Bias in Technical Language In an effort to align with one of our core company values, equality, we have changed terminology to be more inclusive where possible. Because changing terms in code can break current implementations, we maintain the current terminology in the following places: Tableau APIs: methods, parameters, and variables Tableau CLIs: commands and options Installers, installation directories, and terms in configuration files Tableau Resource Monitoring Tool (we plan to make changes to non-inclusive terminology in the web interface, error messages, and related documentation soon.) Third-party systems documentation For more information about our ongoing effort to address implicit bias, see Salesforce Updates Technical Language in Ongoing Effort to Address Implicit Bias on the Salesforce website."
                },
            
		
            
                "/webdataconnector/docs/wdc_authentication.html": {
                    "title": "WDC Authentication",
                    "content": "Many connectors require authentication to connect to a data source. For these connectors, you must handle authentication in your connector code and create a form interface to prompt users for authentication information. Separately, the WDC also includes logic that you can use for re-authentication as a convenience. This topic describes how to re-authenticate users for connectors that have already run. Note: Kerberos is currently not supported with a custom Web Data Connector. Types of authentication Authentication types are used to help users re-authenticate. The WDC API supports the following authentication types: basic. User name and password authentication. custom. Other authentication methods, including OAuth for example. none. No authentication is required. If you do not specify an authentication type, none is assumed. A connector should set its auth type in a custom init method. For example: // Init function for connector, called during every phase myConnector.init = function(initCallback) { tableau.authType = tableau.authTypeEnum.custom; initCallback(); } For connectors that require authentication, the auth type must be set. Otherwise, Tableau will not know how to re-authenticate the user when the user is un-authenticated, which is a common scenario. For example, passwords (or tokens) should be stored in the tableau.password property. The contents of this property are not ever written to disk. So when a user opens a saved workbook that is attached to a WDC data source, there will not a be a password for that source. In that case, if the user wishes to refresh the extract, re-authentication needs to happen first. When the user tries to refresh the data source, one of three things can happen depending on the value of authType. If authType is none, then nothing will happen. If authType is basic, Tableau will show a standard username/password dialog. If authType is custom, Tableau will launch the web data connector in a special Auth Phase (see the following section). After that, the tableau.username and tableau.password property will both have values, and the extract can now be refreshed. Note: authType in part replaced alwaysShowAuthUI from version 1 of the API. The WDC Auth Phase The WDC has two primary phases, as described in the WDC Lifecycle and Phases section. But there is a third phase that is only relevant for WDCs that use an auth type of custom. The auth phase is more of an alternative to the interactive phase than a separate phase. The auth phase will be displayed by Tableau in two scenarios: The WDC uses authType custom, the current user is un-authenticated (as described above, when opening an existing workbook), and the user attempts to refresh the extract or edit the connection. The WDC developer calls tableau.abortForAuth. This method is provided so that the developer can explicitly tell Tableau the current user is un-authenticated. For example, this can be helpful when working with OAuth. In some scenarios, the access token used to get resources from an API can expire or be revoked. In that scenario, before fetching data, the WDC would want to call this method in order to re-authenticate the user. For more information, see the OAuthProxyExample connector included in the SDK. IMPORTANT: The abortForAuth function must be called from the init method during the gather data phase. One intended scenario for this function is when a user, who has not been authenticated, opens an existing workbook and attempts to refresh data. In this case, the auth token is no longer available. In the auth phase of the WDC, any changes to properties other than tableau.password and tableau.username will be ignored. Thus, it is a best practice to only show the UI that is necessary to re-authenticate the user, and then auto-submit the connector for the user once they have been authenticated. For example, in the OAuthProxyExample this is how this is handled in the custom init method: // Init function for connector, called during every phase but // only called when running inside the simulator or tableau myConnector.init = function(initCallback) { tableau.authType = tableau.authTypeEnum.custom; // If we are in the auth phase we only want to show the UI needed for auth if (tableau.phase == tableau.phaseEnum.authPhase) { $(\"#getvenuesbutton\").css('display', 'none'); } if (tableau.phase == tableau.phaseEnum.gatherDataPhase) { // If the API that WDC is using has an endpoint that checks // the validity of an access token, that could be used here. // Then the WDC can call tableau.abortForAuth if that access token // is invalid. } var accessToken = Cookies.get(\"accessToken\"); console.log(\"Access token is '\" + accessToken + \"'\"); var hasAuth = (accessToken &amp;&amp; accessToken.length &gt; 0) || tableau.password.length &gt; 0; updateUIWithAuthState(hasAuth); initCallback(); // If we are not in the data gathering phase, we want to store the token // This allows us to access the token in the data gathering phase if (tableau.phase == tableau.phaseEnum.interactivePhase || tableau.phase == tableau.phaseEnum.authPhase) { if (hasAuth) { tableau.password = accessToken; if (tableau.phase == tableau.phaseEnum.authPhase) { // Auto-submit here if we are in the auth phase tableau.submit() } return; } } }; Advanced: Auth Purpose Mechanism Understanding the content in the OAuthProxyExample included with the SDK is recommended before proceeding on with this or the following section. See the Node.js Proxy with OAuth Tutorial for more information. The tutorial contains helpful terminology that is used without explanation here. Specifically for data sources that use OAuth as an authorization mechanism, there is a special enum in the API that can be useful for making a highly scalable connector. This is an advanced technique and can be safely ignored in many scenarios. The motivation for this property stems from the fact that many OAuth providers only allow a limited number of access tokens to be valid at a given time. For example, certain OAuth providers allow 25 access tokens to be valid for a given user/client pair. If a 26th access token were to be issued, the 1st access token would become invalid. For certain OAuth providers, this number may be even smaller. We have seen OAuth providers that only allow 1 access token to be valid at a given time for any user/client pair. Given this, the following scenario could occur if the WDC was using a source that only allowed one valid access token: A user creates a data source with your WDC (1 access token is created and associated with that data source). The user publishes the data source to Server and enables automatic refreshes. The user creates a second data source (2nd access token is created, rendering the first one invalid). The automatic refresh on server would now fail because the associated access token is invalid. In order to get around this problem, you can associate all data sources created from Tableau Desktop with a given client, and all data sources refreshed on Tableau Server with another client. To do this, in your WDC you can use the tableau.authPurpose to read which context your WDC is currently running in. If that context is ephemeral then the WDC is being run from Tableau Desktop. If the context is enduring, then the WDC is being run on Tableau Server during an automated refresh. You can use this property to set the client ID appropriately when performing OAuth flows. It is also important that your connector sets the tableau.username property to be whatever identity is associated with an access token (most commonly an email or username). This will allow Tableau to share access tokens between data sources on Server so that even if the OAuth provider restricts you to n valid access tokens, you can support more than n data sources. Advanced: Authentication on Server Currently, there is no way to re-authenticate a data source from Tableau Server directly. For example, if you build a connector that uses OAuth as an authorization mechanism, each data source will have an associated access token. But these access tokens can expire, and when that happens, the data source would no longer be usable. Luckily, with OAuth (and often there is a parallel with other types of authorization and authentication mechanisms), there is a way to refresh these access tokens programmatically. For OAuth specifically, we recommend fully implementing the refresh flow so that when an access token expires, the refresh token can be used to get a new, valid access token."
                },
            
		
            
                "/webdataconnector/docs/wdc_cors.html": {
                    "title": "WDC Working with CORS",
                    "content": "The JavaScript code in a web data connector typically makes requests to a server that’s on a different domain than the one that’s hosting the web data connector’s HTML page. That is, the code makes requests that represent cross-origin resource sharing (CORS). As a security measure, most browsers restrict CORS requests made from JavaScript code. This restriction can result in errors when the web data connector runs. For example, if the code in your connector makes requests to a server that doesn’t allow CORS requests, you might see an error like the following in your browser console: XMLHttpRequest cannot load URL. No 'Access-Control-Allow-Origin' header is present on the requested resource. If your connector experiences CORS-related errors when trying to access another site, you can try the approaches listed in this topic: Note: For information about how to use the Web Data Connector simulator to help debug errors, including CORS errors, see Debugging in the Simulator and Tableau. Make requests through a proxy server To circumvent browser restrictions on CORS, you can use a proxy server. A proxy server acts as a simple go-between for your connector and the server that you want to get data from. Because a proxy server doesn’t run in a browser, it isn’t limited by the same restrictions on CORS. If the proxy server is in the same domain as the web data connector, JavaScript in the connector page does not run into CORS restrictions. If the proxy server is in another domain, the proxy server can be configured to set the Access-Control-Allow-Origin header to allow requests from the connector’s domain. The WDC SDK comes with a test proxy server that you can use out of the box. From the top-level directory of the repository, open a command prompt or terminal and run the following command: npm start The test proxy server and test web server start. In your connector code, prefix your requests with the following URL: http://localhost:8889 For example, for the earthquakeUSGS connector, you would change the $.getJSON function from this: $.getJSON(\"http://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_week.geojson\", ... To this: $.getJSON(\"http://localhost:8889/earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_week.geojson\", Important: The test proxy server supports HTTP API calls only. If you want to share your connectors with other users in your organization, you can download and configure a production proxy server, or you can use a free, public proxy server like https://cors-anywhere.herokuapp.com/. Request CORS support from API Server To allow CORS requests, the server that hosts the data can set the Access-Control-Allow-Origin header in the response. The header can be set to specific domains (for example, http://example.com), or to * to indicate that all domains are allowed access to the server’s data. To get CORS support for requests from your connector, you can contact the owners of the site that hosts the data you are querying and ask them to add the Access-Control-Allow-Origin header with your domain in it, or to add your domain if the site already sends the header. For more information, see HTTP access control on the Mozilla Developer Network site. Make requests with JSONP If the site that contains the data doesn’t support CORS, it’s often possible to get data from the site by using JSON with padding, or JSONP. JSONP provides an alternative to making requests directly in JavaScript, since those are blocked. Instead, you use JavaScript to dynamically create or update a &lt;script&gt; element and set its src attribute to a URL that points to the site that has the data. The URL also contains the name of a callback function that’s in the connector page. If the site supports JSONP, the response includes the data in JSON format, “padded” with a call to the callback function. If you use jQuery in your web data connector, you can make JSONP calls using the ajax function. For more information, see jQuery.ajax() on the jQuery site. If you aren’t using jQuery, you can implement JSONP in your JavaScript code. For example, a connector might contain the following JavaScript code, which dynamically creates a &lt;script&gt; element and sets its src attribute to the URL of a server that has a fictional temperature service. The URL includes various parameters; one of the parameters is the name of a callback function. When the new &lt;script&gt; element is created, the browser invokes the URL that the src attribute is set to. var scriptTag = document.createElement('script'); scriptTag.src = \"http://myserver/temperatures?city=Seattle&amp;year=2014&amp;callback=getTemperatures\"; document.getElementsByTagName('head')[0].appendChild(scriptTag); The connector must also include the following function, which is invoked by the “padded” JSON that the temperature site returns. The JSON data is passed to the function as the jsonpData parameter, and the code in the function can extract values as it would from any JSON block. var getTemperatures = function(jsonpData) { alert(jsonpData.someProperty); // More code here to extract the JSON data } For more information, see JSONP on Wikipedia."
                },
            
		
            
                "/webdataconnector/docs/wdc_custom_init_and_shutdown.html": {
                    "title": "WDC Custom Initialization and Shutdown",
                    "content": "Your code might need to open a resource or perform a setup task for the data source. If so, you can run initialization code that is invoked at the beginning of each phase. If you don’t need custom initialization logic, you don’t need to do anything; code in the Tableau JavaScript library includes default initialization logic for you. To implement custom initialization, you create an init function for your connector. In the function, run your initialization code. When initialization is complete, call the passed in initCallback to tell Tableau that initialization is finished, as in this example: myConnector.init = function(initCallback){ // Your init code here initCallback(); }; One typical scenario for using custom initialization code is to tell tableau about the auth needs of your connector. Please see WDC Authentication for details on this. Similarly, if your connector needs to perform custom shutdown logic, you create a shutdown function for the connection. When the shutdown process is complete, call the passed in shutdownCallback, as in this example: myConnector.shutdown = function(shutdownCallback) { // Your shutdown code here shutdownCallback(); } As with initialization, if you don’t need custom shutdown logic, you can leave this out, because the code in the Tableau JavaScript library takes care of it for you. The initialization or shutdown code is called once per phase. The code is called during the interaction phase and again during the gather data phase. If your initialization or shutdown code depends on which phase the connector is in, you can test the tableau.phase property. This property returns a string value that indicates the phase that the connector is in: tableau.phaseEnum.interactivePhase, tableau.phaseEnum.gatherDataPhase, or tableau.phaseEnum.authPhase. The following example shows how to use this property. myConnector.init = function(initCallback) { initCallback(); if(tableau.phase == tableau.phaseEnum.interactivePhase || tableau.phase == tableau.phaseEnum.authPhase) { tableau.submit(); } }; Running the connector without user interaction If your connector doesn’t require user input, you don’t need to create a user interface for your connector. You just need to call tableau.submit when the connector has finished initializing. Include the following code to run a connector without user interaction: myConnector.init = function(initCallback) { initCallback(); tableau.submit(); };"
                },
            
		
            
                "/webdataconnector/docs/wdc_debugging.html": {
                    "title": "Debugging in the Simulator and Tableau",
                    "content": "You can use the simulator included with the WDC SDK to develop and debug your connectors more quickly. The simulator is a JavaScript application that loads connectors in a similar way to Tableau Desktop. Additionally, starting with Tableau Desktop 2019.4, you can use the Chrome DevTools and the Chromium debugger to debug issues that appear in Tableau Desktop, but not in the simulator. A WDC is a web page that runs in a Chromium-based browser inside of Tableau Desktop. In versions of Tableau Desktop prior to 2019.4, you can use a built-in—although, not supported—debugger that you can use to debug WDC issues that appear in those versions of Tableau Desktop. Use the simulator when you are developing your connector, to set breakpoints in the browser, view network requests, and more. Use Tableau Desktop periodically during development to confirm that your connector works the same as in the simulator, and then to perform your final testing. This page includes information about developing and debugging your connectors both in the simulator and in Tableau. Debugging in the simulator To set up and run the simulator, follow the instructions in the Get Started section. When you run a connector in the simulator, only the getSchema and getData parts of your connector code run in the simulator window. The interactive phase and authentication phases run in a separate window. This means that messages that you print with console.log will appear in different browser consoles. To print messages from both windows to the console for the main simulator window, use tableau.log. For example, you might enter the following in your code: tableau.log(\"My console message goes here!\"); Simulator tips By default, the test web server runs on port 8888. To change the port number, edit the http-server script in the package.json file. For example, you might enter the following to change the port to 8000: \"http-server\": \"export SERVER_PORT=8000 || set SERVER_PORT=8000 &amp;&amp; node ./index.js\" To make it easier to load files into the simulator, keep the simulator and web data connector .html files that you are testing in the same folder. Note: Tableau 2019.4 (and later) embeds the Qt WebEngine browser into the product to display your connector pages. Qt WebEngine is a Chromium-based browser that provides support for HTML5 and other modern features, including the ability to use the Chromium and Chrome DevTools for debugging. Tableau Desktop 2019.3 (and earlier) embeds the Qt Webkit browser. This browser might lack some of the features of modern browsers, including specific HTML5 features. For more information on browser support, see the features in Qt 5.7, which is the version used by Tableau (10.3 to 2019.3). You might also want to see the Qt Webkit documentation on HTML5 support and the Qt Webkit HTML5 Score . Caching in the simulator If changes to your connector do not appear to take effect in the simulator, the browser might be caching a previous version of your connector. Here are some ways to work around caching issues: In some browsers, you can press Ctrl+Shift+R or Cmd+Shift+R to clear the cache for the current page and reload it. Open the simulator in an incognito window which does not store cookies or cache pages. Note that the list of recent connectors will not be stored if cookies are disabled. In Google Chrome, you can disable caching while the developer tools are open. Open Chrome Developer Tools. Press F1 to view the settings. On the Preferences tab, under Network, select the Disable caching option. General browser debugging tips Open the developer tools console for the browser. For example, in Google Chrome press Ctrl+Shift+I on Windows or Command+Option+I on the Mac to open the tools pane, and then select the Console tab. In this console, you can see all the results of various console.log statements. The console also displays output from the tableau.log and tableau.abortWithError functions. This is a good place to check for errors in case anything goes wrong. The console will display information about run-time errors (unhandled exceptions) that occur while your code is running. If an error occurs, the JavaScript engine in the browser throws an error and the error message is displayed in the console. Use a debugger to step through your code. Most browsers include a debugger as part of their developer tools. You can set breakpoints in your code in the debugger or include JavaScript debugger statements. When the web data connector runs and the browser’s developer tools are open, code execution stops at breakpoints or debugger statements and you can examine variables. For an overview of debugging tools, see JavaScript Debugging on the W3CSchools.com site. Debugging a WDC in Tableau Desktop 2019.4 (and later) Starting with Tableau 2019.4, you can use the Chromium browser and the Chrome DevTools to debug your WDC while it is running in Tableau Desktop. This means you can use the Chromium browser, instead of the unsupported “Beta” debugger that was built into Tableau Desktop. Download the Chromium Browser To debug your WDC, you’ll need to use a Chromium-based browser (Chromium is the open-source version of Chrome). In some cases you could use Chrome, but because of version incompatibilities in the debugging protocol, we recommend using specific builds of Chromium, which matches the version of the browser running inside Tableau. Just download and unzip the file and run chrome.exe (Windows) or chromium (macOS). Tableau Desktop version Chromium version Chrome version Prior to 2019.4 Not Available Not available 2019.4 and later Chromium version 79 or earlier (for example, 79.0.3945.0) Chrome version 79 or earlier. Chromium downloads for debugging Tableau 2019.1 and later Chromium for Windows (chrome-win.zip) (79.0.3945.0) Chromium for macOS (chrome-mac.zip) (79.0.3945.0) Note If you are using Tableau 2019.1 or later, you can debug WDCs in Tableau Desktop using certain versions of Chrome (versions prior to 80). Currently, you can't use Chrome version 80 (or later) for debugging your WDC. Start Tableau with remote debugging enabled (Windows) Open a command prompt. Navigate to the Tableau Desktop directory. Replace &lt;version&gt; with the version of Tableau you are using (for example,Tableau 2019.4). cd C:\\Program Files\\Tableau\\Tableau &lt;version&gt;\\bin\\ Start Tableau with the remote debugging option. tableau.exe --remote-debugging-port=9000 This command enables remote debugging of your WDC for this session of Tableau. Note: The remote debugging port (for example, 9000) must match the port address you use with the Chrome browser for debugging. This is not the HTTP port that you are using to host your WDC. Start Tableau with remote debugging enabled (macOS) Open a Terminal window. Start Tableau using the following command. Replace &lt;version&gt; with the version of Tableau you are using (for example,2019.4.app). open /Applications/Tableau\\ Desktop\\ &lt;version&gt;.app --args --remote-debugging-port=9000 This command enables remote debugging of your WDC for this session of Tableau. Note: The remote debugging port (for example, 9000) must match the port address you use with Chrome for debugging. This is not the HTTP port that you are using to host your WDC. Debugging a WDC in Tableau Desktop using Chromium After you enable debugging in Tableau, you can start debugging your WDC with the Chrome DevTools. Connect to a web data connector. In Tableau, open a connection to the Web Data Connector. In the WDC dialog box, enter the URL of the WDC you want to debug, and press Enter. After your WDC landing page is loaded, you will want to wait before interacting with the page so you can start the Chrome debugger and set breakpoints. Start Chrome and set the URL to http://localhost:9000 This will bring up the page selector UI. The port (for example, 9000) must match the port address you specified as the remote debugging port when you started Tableau. In the Chrome Browser, select the WDC you want to debug from this page (under Inspectable pages). Note that the name of the WDC is based on the title of the web page that was loaded for the WDC. When the Chrome debugger is connected, switch to the Sources tab and set a breakpoint (or breakpoints) in your WDC source code (for example, on the getSchema and getData methods). Switch back to Tableau and interact with the WDC. The WDC will run until it hits the breakpoint. Switch back to the Chrome browser and use the developer tools to step through your source code, examine variables, and watch the Console for messages. Debug your WDC initial startup code If you want to debug the initial startup of your WDC, you can set an Event Listener Breakpoint to break on the first statement whenever a JavaScript file is loaded. Then you can open the WDC home page in Tableau and connect the debugger. When you load your WDC, the debugger will break on the first module. Start Tableau in debugging mode and open the Web Data Connector dialog box. Switch to the the Chrome browser and use the developer tools (localhost:9000) and select the WDC Home page. Click the Sources pane in the debugger, and then click Event Listener Breakpoints. Under Script, select Script First Statement. Go back to Tableau and enter the URL for your WDC. When the WDC loads, the debugger will break on the first module of your source code. Use the Chrome Developer Tools to step through the start up code. Debugging a WDC in Tableau Desktop 2019.3 (and earlier) Tableau Desktop includes a built-in debugger that you can use to test your connectors. Use the built-in debugger when you encounter differences that you cannot debug in the simulator. Important: The built-in debugger only runs on Windows. It is provided as-is and without official support by Tableau. The debugger communicates with Tableau Desktop synchronously and therefore might appear unresponsive at times. To run the built-in debugger, complete the following steps: Open a command prompt. Navigate to the Tableau Desktop directory. cd \"C:\\Program Files\\Tableau\\Tableau &lt;version&gt;\\bin\\\" Run Tableau Desktop with the debugging flag: tableau.exe -DDebugWDC Connect to a web data connector. Interact with your connector and start the data gathering phase. The built-in debugger loads. The first time that you use the debugger, click the Sources tab, select Always enable, and click Enable Debugging. Click the Show sources button to display a list of the files used in your connector. Select a file to open it. To set a breakpoint, click on a line number. Press F8 to continue running your connector."
                },
            
		
            
                "/webdataconnector/docs/wdc_faq.html": {
                    "title": "Frequently Asked Questions",
                    "content": "Where can I find known issues? You can view open issues, and submit new issues, on our Github issues page. Can I still use version 1.0 of the WDC API? Where can I find information about version 1.0 of the WDC? If you are creating a new connector for Tableau 10.0 or later, you should use version 2 of the WDC API. However, version 1.0 of the WDC API will continue to work in Tableau 10.0. Additionally, Tableau 9.3 and earlier only support version 1.0 of the WDC API. For information about version 1.0 of the WDC, see the archived documentation and simulator. Can I contact Tableau for help with my connector? Tableau does not provide support for connectors or for other programs written to interface with the WDC API. However, you can submit questions and ask for help on the Tableau developer community forums. Tableau does provide support for the WDC library and SDK though. If you find an issue with the WDC library, the simulator, or any of the developer samples, submit an issue on Github. The global variables in my connector display as undefined. What’s happening? The WDC API runs connectors in multiple phases, and each phase runs in a separate instances of a web browser. To pass data between phases, use the tableau.connectionData variable created by the API for this purpose. For more information, see the documentation for the phases of the web data connector. Why are my extract refreshes failing on Tableau Server? To run extract refreshes for connectors, you need to configure Tableau Server and import the connector. Contact your server administrator and see the Tableau Server documentation on web data connectors. Can I refresh extracts for connectors on Tableau Online? Because running custom code for a connector represents a security risk, there is currently no way to refresh extracts for connectors published to Tableau Online. As an alternative, you can use the Tableau Online Sync Client to schedule extract refreshes on a desktop computer. Where are the check boxes and radio buttons that I put in my connector page? I see them in the simulator, but not in Tableau. This was an issue in a previous version of the WDC. To fix the issue, get the latest version of the WDC from the WDC Versions page. I’m seeing differences between what I see in the simulator and what I see in Tableau. What’s going on? Tableau Desktop embeds the Qt Webkit browser into the product to display your connector pages. This browser might lack some of the features of modern browsers, including specific HTML5 and other features. For more information on browser support, see the features in Qt 5.4, which is the version used by Tableau. You may also want to see the Qt Webkit page on HTML5 support. Where can I find the Tableau Desktop logs to troubleshoot my connector? By default, the Tableau Desktop log files are stored in the following location: Users/&lt;username&gt;/Documents/My Tableau Repository The log.txt file contains information for the interactive phase of your connector. The tabprotosrv.txt file contains logs for the data gathering phase. The Tableau Log Viewer is an open source tool that makes it easier to read Tableau logs: https://github.com/tableau/tableau-log-viewer. Why aren’t my connector methods being called? The methods in your connector code are run by the WDC API. Ensure that you are running the connector in the simulator or Tableau. You might also want to ensure that the tableau.submit function is being called either by user input or by a page load event. Can I get the links in my WDC in Tableau to open in an external browser? Why yes, yes you can! Just add the target=\"_blank\" property to the anchor element in your web page and it will open in the user’s default browser instead of opening in Tableau. For example, you might enter the following link: html &lt;a href=\"http://tabsoft.co/wdc\" target=\"_blank\"&gt;Hello Docs!&lt;/a&gt; What parts of the WDC SDK can I contribute to? We will happily take contributions to anything in the WDC SDK aside from the core library (i.e. tableauwdc-version.js). This includes the simulator, documentation, and samples. We cannot take contributions to the library file because that file represents a bridge between a WDC and proprietary Tableau platform code. For more info on open source at Tableau, visit http://tableau.github.io/."
                },
            
		
            
                "/webdataconnector/docs/wdc_get_data.html": {
                    "title": "Get Data - Best Practices",
                    "content": "In the WDC Gather Data Phase, it’s a best practice to insert data into the extract you create in manageable amounts. This is often called data chunking or paging and it can help improve performance and can keep the WDC from overloading Tableau, and can provide a better experience for end-users because they can see regular progress indicators. This best practice is important when you are working with very large data sets. Note: In Tableau 2019.4 and later, Web Data Connectors use Qt WebEngine as the internal browser. The version of the Qt WebEngine we currently use has a limitation in its data communication channel of approximately 128MB. If your WDC appends more data than can be transmitted at one time, the WDC is created and initialized, but no data is added. To avoid this problem, be sure to insert your data in chunks that are less than 128MB. For more information about this issue, see Troubleshoot WDC WebEngine Issues in Tableau 2019.4 and later. This topic describes an approach that could be used to add data in chunks during the WDC Gather Data Phase. In this section: Append rows in the WDC Gather Data Phase You might recall from the WDC lifecyle diagram shown in WDC Lifecyle and Phases, the WDC Gather Data Phase includes the call to getData, which is called once for each schema (or table). Within that getData function call, you can call table.appendRows as many times as you need to append data to the table that is created. The appendRows function allows you to insert your data in manageable chunks. The diagram legend is as follows. Determine how to split your data How you determine the amount of data to append at a time depends upon the overall size of your data. If your data is very large (over 128MB, for example), you will need to break it down in to smaller chunks. If you data set is small, you might not need to chunk it at all. The appendRows function has one parameter, which can be an array of arrays or an array of objects. A common way to split the data is by having the same number of rows in each chunk. Some rows may be larger in size than others, so you may have to iterate to find an appropriate number of rows. The following appendRows example shows how you might create a size variable and use that with a row count variable to iterate through the data. Rather than building the extract all at once with the call to table.appendRows, the WDC uses a while loop to call the appendRows function iteratively based upon the row index and the size we chose to increment. In this example, we use a size variable that is an arbitrary integer that determines how much of the data to append. It represents the number of items in the array to add at one time. In this example, we use the JavaScript slice function to split the tableData array into smaller chunks. The size we use is 100, so 100 rows from the tableData array are added to the extract at a time. For large data sets, you would probably want to use a larger value to improve the performance. Be sure to use a size value that keeps amount of data added in each appendRows call under 128MB. // called inside the getData function // after we populate the tableData var row_index = 0; var size = 100; while (row_index &lt; tableData.length){ table.appendRows(tableData.slice(row_index, size + row_index)); row_index += size; tableau.reportProgress(\"Getting row: \" + row_index); } Use the reportProgress function to log your commits The appendRows example also makes use of the reportProgress function. This function allows you to follow the progress of the Gather Data phase in Tableau. It is a best practice to call this function as you add your data to the extract. Note that the reportProgress function is intended to inform Tableau Desktop users. Tableau Server users will not see the message, and calling the reportProgress function with a very high frequency could adversely affect performance. Note also that calling console.log or tableau.log in a similar manner with very high frequency could also affect performance. tableau.reportProgress(\"Getting row: \" + row_index); The progress is displayed in Tableau. For example, when you first load your WDC you are taken to the Data Source pane. When you click the Sheet 1 tab for the first time, the worksheet opens and the Create Extract dialog box appears and reports the progress. This can be helpful when you are loading a very large data set. With a small data set, the extract creation process goes quickly, so you might not see the progress dialog if the size increment you use is large. Example code: EarthquakeUSGS The following example is based upon the Tutorial and the EarthquakeUSGS sample. It is a slightly modified version of the earthquakeUSGS.js file you created in the tutorial. In this case, rather than building the extract all at once with the call to table.appendRows, the WDC uses a while loop to call the appendRows function iteratively based upon the row index and the size we chose to increment. The example also looks at a larger data set, in this case all the earthquakes (of any size) reported in the last month. In this example, we create a function called chunkData that is a wrapper for the while loop we used in the previous example. Our chunkData function is called from the WDC getData function. You could create a function similar to this in your own WDC. Our chunkData function takes table and tableData as arguments. In our function, we use a size variable, which is an arbitrary integer value that we use to determine how much of the data we want to append. The data set we are using isn’t very large (less than 8MB). In this case, we chose 100 but you might need to use a larger value in your own function for better performance. Progress is reported as each row is added. (function() { // Create the connector object var myConnector = tableau.makeConnector(); // Define the schema myConnector.getSchema = function(schemaCallback) { var cols = [{ id: \"id\", dataType: tableau.dataTypeEnum.string }, { id: \"mag\", alias: \"magnitude\", dataType: tableau.dataTypeEnum.float }, { id: \"title\", alias: \"title\", dataType: tableau.dataTypeEnum.string }, { id: \"location\", dataType: tableau.dataTypeEnum.geometry }]; var tableSchema = { id: \"earthquakeFeed\", alias: \"All earthquakes in the last 30 days\", columns: cols }; schemaCallback([tableSchema]); }; // Download the data myConnector.getData = function(table, doneCallback) { $.getJSON(\"https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.geojson\", function(resp) { var feat = resp.features, tableData = []; // Iterate over the JSON object for (var i = 0, len = feat.length; i &lt; len; i++) { tableData.push({ \"id\": feat[i].id, \"mag\": feat[i].properties.mag, \"title\": feat[i].properties.title, \"location\": feat[i].geometry }); } // add the data chunkData(table, tableData); doneCallback(); }); }; // add the data in manageable chunks function chunkData(table, tableData){ var row_index = 0; var size = 100; while (row_index &lt; tableData.length){ table.appendRows(tableData.slice(row_index, size + row_index)); row_index += size; tableau.reportProgress(\"Getting row: \" + row_index); } } tableau.registerConnector(myConnector); // Create event listeners for when the user submits the form $(document).ready(function() { $(\"#submitButton\").click(function() { tableau.connectionName = \"USGS Earthquake Feed\"; // This will be the data source name in Tableau tableau.submit(); // This sends the connector object to Tableau }); }); })();"
                },
            
		
            
                "/webdataconnector/docs/wdc_hosting_and_submissions.html": {
                    "title": "Hosting and Submitting to the Community Portal",
                    "content": "Submit your connector to the Community Connector portal to share your work with other developers. To make it easier for others to use your connector, we ask that you include a link to a hosted version of your connector. If you don’t have a hosted version yet, see our suggestions for hosting. Submitting to the Community Portal Note: Before you submit a connector, you’ll need a Github account. Click on the link below to go to our list of connectors: https://github.com/tableau/webdataconnector/blob/master/community/community_connectors.json Click the Edit icon on the right. Create a new JSON entry for your connector with a name, author, and URL to a hosted version. Optionally, you can enter a description, Github user name, link to the source code, and tag for the version of the WDC API. For example, you might enter the following: { \"name\": \"My Cool Connector\", \"url\": \"https://xyz.com/connector.html\", \"author\": \"Me\", \"github_username\": \"\", \"tags\": [\"v_2.0\"], \"description\": \"This connector is really cool\", \"source_code\": \"github.com/Me/MyConnector\" } Scroll to the bottom of the page and enter a description for your change. Click the Propose file change button at the bottom of the page. Click the Create pull request button. Confirm your changes on the next page, then click Create pull request one more time. That’s it! A member of our web data connector team will review your changes and merge them into the repository. Suggestions for hosting your connector There are several free hosting services that you can use for connector. You can host your connector anywhere you please, but we have two suggested locations that we have seen to be the easiest to use. Host your static content on GitHub pages. If your connector is composed of client side code only (just HTML/CSS/JS files), you can host your content for free on GitHub Pages (This is actually what’s hosting the documentation you are currently reading!). GitHub Pages makes it really easy to host content, especially if your connector code is already on GitHub. Check out their tutorial for details: pages.github.com/ Host your node app on Heroku. If your connector contains a sever component, like the Node Proxy sample, you can host your connector for free on Heroku. There are certain usage restrictions; for example their free tier requires the connector to be offline for a few hours a day. Check out their tutorial for more details: Heroku Tutorial"
                },
            
		
            
                "/webdataconnector/docs/wdc_incremental_refresh.html": {
                    "title": "WDC Incremental Refresh",
                    "content": "Tableau uses web data connectors to fetch data and store that data in an extract. You can always refresh the entire extract. However, if you implement incremental refresh, you can also fetch only the new data for the extract, which can greatly reduce the time required to download the data. It is possible to enable incremental refresh functionality for any table that is brought back by the web data connector. To enable incremental refresh functionality on a table, you must set the tableInfo.incrementColumnId property on the tableInfo object for that table as defined in your getSchema function. The incrementColumnId property should be set to the ID of the column that will be used as the key for the incremental refresh. For example, suppose you had a table with an ID field. For every new record in the table, the ID is incremented by 1, and no previous data is ever deleted or overwritten. In that scenario, you would want the ID column to be referenced by incrementColumnID. That way, when gathering data, you can fetch only the records that have an ID that is larger than the largest ID you have fetched during the last gather data phase. For example, here is the getSchema method of the IncrementalRefreshConnector dev sample: myConnector.getSchema = function(schemaCallback) { var cols = [ { id: \"id\", dataType: tableau.dataTypeEnum.int }, { id: \"x\", dataType: tableau.dataTypeEnum.string }, { id: \"day\", dataType: tableau.dataTypeEnum.datetime }, { id: \"day_and_time\", dataType: tableau.dataTypeEnum.datetime }, { id: \"true_or_false\", dataType: tableau.dataTypeEnum.bool }, { id: \"color\", dataType: tableau.dataTypeEnum.string } ]; var tableInfo = { alias: \"Incremental Refresh Connector\", id: \"mainTable\", columns: cols, incrementColumnId: \"id\" }; schemaCallback([tableInfo]); }; When Tableau calls the getData method of the connector, it passes in a table object. If an incremental refresh is being requested by the end user in Tableau, and if the tableInfo.incrementColumnId was set during the getSchema function for that table, then the table object will contain a value in the table.incrementValue property. This value will contain the current largest value from the increment column. For example, this is how this property is utilized in the IncrementalRefreshConnector dev sample: myConnector.getData = function(table, doneCallback) { var lastId = parseInt(table.incrementValue || -1); // Gather only the most recent data with an ID greater than 'lastId' // ...... table.appendRows(dataArray); doneCallback(); }; The WDC API supports three data types for the incremental refresh column: DateTime, Date, and integer. For incremental refresh, you typically use a field that represents a date, a timestamp, or a row number."
                },
            
		
            
                "/webdataconnector/docs/wdc_join_filtering.html": {
                    "title": "Join Filtering",
                    "content": "When you connect to multiple tables of data with a web data connector, you can filter the data from one table based on the data from another table. Said another way, you can make one table dependent on the data returned from another table. Use join filtering to improve the efficiency of your connectors by getting only the data that you want. Otherwise, by default, Tableau gets all data from all tables. Before you set up join filtering, ensure that you have a working web data connector for your tables. For more information on getting data from multiple tables, see the Multiple Tables Tutorial. Once you have a working connector for multiple tables, step through the following example to understand join filtering (or review the example connector at the end). Important: Join filtering is only supported in WDC versions 2.2 and later. Create a sample schema In this example, you create a connector for blog post data where you join two tables: a users table and a posts table. You can use join filtering to first get data from the users table, then only get post data that corresponds to certain users. Here is an example schema for the users table and posts table: var users_cols = [{ id: \"id\", dataType: tableau.dataTypeEnum.string }, { id: \"name\", alias: \"name\", dataType: tableau.dataTypeEnum.string }]; var usersTable = { id: \"users\", alias: \"User Data\", columns: users_cols }; var posts_cols = [{ id: \"id\", dataType: tableau.dataTypeEnum.string }, { id: \"userId\", alias: \"userId\", dataType: tableau.dataTypeEnum.string }, { id: \"title\", alias: \"title\", dataType: tableau.dataTypeEnum.string }]; var postsTable = { id: \"posts\", alias: \"Post Data\", columns: posts_cols }; Specify schema properties Now that you have a sample schema, you can specify which tables you want join and which columns you want to use for the primary to foreign key relationship. To filter posts by user, set the following schema properties: joinOnly. (Optional) Whether you want to make join filtering required for this table. If you set this value to true, you cannot connect to the table without first connecting to the other table. For example, if you set this to true for the posts table, the posts table is disabled in Tableau unless you select the users table first. filterable. Set to true for the column that you want to use for filtering. Because we want the posts tables to be filtered on its userId column, you want to set this to true for the userId column of the posts table. foreignKey. Specify the tableId and columnId to create the primary to foreign key relationship. The posts table userId column represents a foreign key to the users table id primary key. Set the foreignKey property on the userId column of the posts table and point to the primary key: foreignKey: { \"tableId\": \"users\", \"columnId\": \"id\" }. You can have many foreignKey attributes point to the same primary key. The schema below has these properties already set: var users_cols = [{ id: \"id\", dataType: tableau.dataTypeEnum.string, }, { id: \"name\", alias: \"name\", dataType: tableau.dataTypeEnum.string }]; var usersTable = { id: \"users\", alias: \"User Data\", columns: users_cols }; // Schema for posts var posts_cols = [{ id: \"id\", dataType: tableau.dataTypeEnum.string }, { id: \"userId\", alias: \"userId\", dataType: tableau.dataTypeEnum.string, filterable: true, foreignKey: { \"tableId\": \"users\", \"columnId\": \"id\" } }, { id: \"title\", alias: \"title\", dataType: tableau.dataTypeEnum.string }]; var postsTable = { joinOnly: true, id: \"posts\", alias: \"Post Data\", columns: posts_cols }; Get data for tables Because the table that you want to filter depends on data from another table, you need to include additional logic to iterate over the filter values. The dependent table includes the following properties that you can use: isJoinFiltered. Whether the table can be used for join filtering. If the schema properties are set correctly, this equals true. filterValues. An array of the values to use for filtering. For example, an array of the user ID values to get data for. For example, you might iterate through the user ID filter values with the following getData function: myConnector.getData = function(table, doneCallback) { var tableData = []; if (table.tableInfo.id === \"users\") { $.getJSON(\"http://jsonplaceholder.typicode.com/users\", function(resp) { for (var i = 0; i &lt; resp.length; i++) { // Only return the first 5 users to demonstrate filtering if (resp[i].id &lt;= 5) { tableData.push({ \"id\": resp[i].id, \"name\": resp[i].name }); } } table.appendRows(tableData); doneCallback(); }); } else if (table.tableInfo.id === \"posts\") { var filterValues = table.filterValues; if (!table.isJoinFiltered) { tableau.abortWithError(\"The table must be filtered first.\"); return; } if (filterValues.length === 0) { doneCallback(); return; } var postFetches = []; // Now that we have the ids of the filtered users, // get the posts for only those users. for (var userId in filterValues) { var postFetch = new Promise(function(resolve, reject) { $.getJSON(\"http://jsonplaceholder.typicode.com/posts?userId=\" + userId, function(resp) { for (var i = 0; i &lt; resp.length; i++) { tableData.push({ \"id\": resp[i].id, \"userId\": resp[i].userId, \"title\": resp[i].title }); } table.appendRows(tableData); resolve(); }); }); postFetches.push(postFetch); } Promise.all(postFetches).then(function(values) { doneCallback(); }) } }; Full example The full code for the example above is displayed below: (function() { // Create the connector object var myConnector = tableau.makeConnector(); // Define the schema myConnector.getSchema = function(schemaCallback) { // Schema for users var users_cols = [{ id: \"id\", dataType: tableau.dataTypeEnum.string, }, { id: \"name\", alias: \"name\", dataType: tableau.dataTypeEnum.string }]; var usersTable = { id: \"users\", alias: \"User Data\", columns: users_cols }; // Schema for posts var posts_cols = [{ id: \"id\", dataType: tableau.dataTypeEnum.string }, { id: \"userId\", alias: \"userId\", dataType: tableau.dataTypeEnum.string, filterable: true, foreignKey: { \"tableId\": \"users\", \"columnId\": \"id\" } }, { id: \"title\", alias: \"title\", dataType: tableau.dataTypeEnum.string }]; var postsTable = { joinOnly: true, id: \"posts\", alias: \"Post Data\", columns: posts_cols }; schemaCallback([usersTable, postsTable]); }; // Download the data myConnector.getData = function(table, doneCallback) { var tableData = []; if (table.tableInfo.id === \"users\") { $.getJSON(\"http://jsonplaceholder.typicode.com/users\", function(resp) { for (var i = 0; i &lt; resp.length; i++) { // Only return the first 5 users to demonstrate filtering if (resp[i].id &lt;= 5) { tableData.push({ \"id\": resp[i].id, \"name\": resp[i].name }); } } table.appendRows(tableData); doneCallback(); }); } else if (table.tableInfo.id === \"posts\") { var filterValues = table.filterValues; if (!table.isJoinFiltered) { tableau.abortWithError(\"The table must be filtered first.\"); return; } if (filterValues.length === 0) { doneCallback(); return; } var postFetches = []; // Now that we have the ids of the filtered users, // get the posts for only those users. for (var userId in filterValues) { var postFetch = new Promise(function(resolve, reject) { $.getJSON(\"http://jsonplaceholder.typicode.com/posts?userId=\" + userId, function(resp) { for (var i = 0; i &lt; resp.length; i++) { tableData.push({ \"id\": resp[i].id, \"userId\": resp[i].userId, \"title\": resp[i].title }); } table.appendRows(tableData); resolve(); }); }); postFetches.push(postFetch); } Promise.all(postFetches).then(function(values) { doneCallback(); }) } }; tableau.registerConnector(myConnector); // Create event listeners for when the user submits the form $(document).ready(function() { $(\"#submitButton\").click(function() { tableau.connectionName = \"JSONPlaceholder\"; // This will be the data source name in Tableau tableau.submit(); // This sends the connector object to Tableau }); }); })();"
                },
            
		
            
                "/webdataconnector/docs/wdc_library_versions.html": {
                    "title": "WDC Versions",
                    "content": "Every web data connector must include a reference to the Tableau WDC library. You can get the latest version of the WDC here: https://connectors.tableau.com/libs/tableauwdc-2.4.latest.js There is also a minified version available: https://connectors.tableau.com/libs/tableauwdc-2.4.latest.min.js The above URLs are the recommended ways of linking to the Tableau WDC and guarantee that you receive patch versions for the current minor version as we release them. If you prefer to opt out of receiving automatic patch versions, you can link directly to a specific patch version, for example: https://connectors.tableau.com/libs/tableauwdc-2.1.1.js https://connectors.tableau.com/libs/tableauwdc-2.1.1.min.js Compatibility with versions of Tableau The following table displays which versions of the WDC are compatible with Tableau Desktop: WDC version Tableau version tableauwdc-2.4.0 2021.1.2 or later tableauwdc-2.3.0 10.4 or later tableauwdc-2.2.0 10.2 or later tableauwdc-2.1.0 10.1 or later tableauwdc-2.0.2 10.0 and later tableauwdc-2.0.0 10.0 through 2019.2 tableauwdc-1.1.1 9.3 through 2019.29.2.4 through 2019.2 9.1.6 through 2019.2 tableauwdc-1.1.0 9.2.0 through 9.2.3 9.1.0 through 9.1.5 In Tableau Desktop, if you try to open a connector that uses an incompatible version of the WDC, you might see an error like the following: The version of Tableau that you are using cannot use the web data connector that you are trying to access. The connector requires at least version 'x.x' of the web data connector API. Note: This site is for version 2 of the WDC, and is only be compatible with Tableau 10.0 and later. Version 1 of the WDC is no longer supported. If you are a developer, see Upgrading from WDC Version 1.x for information about migrating your WDC to version 2."
                },
            
		
            
                "/webdataconnector/docs/wdc_multi_table_tutorial.html": {
                    "title": "WDC Multiple Tables Tutorial",
                    "content": "This tutorial builds on the connector created in the basic tutorial. Ensure that you understand the concepts in the basic tutorial before you continue. By the end of this tutorial, you will know how to store data in multiple tables and pass user input to your connector. You’ll learn how to: To see the source code for the completed connector, look for the earthquakeMultitable files in the Examples directory. Before you get started This tutorial builds on the USGS Earthquake feed connector created in the tutorial. Before you get started, you’ll need to make a copy of the connector that you can edit. Copy the earthquakeUSGS files from the Examples directory and the js directory to the top-level directory for the repository. (This is the same directory as the README.) Rename the files to earthquakeMultitable.html and earthquakeMultitable.js. Edit the earthquakeMultitable.html file to point to the renamed earthquakeMultitable.js file: &lt;script src=\"earthquakeMultitable.js\" type=\"text/javascript\"&gt;&lt;/script&gt; Create the user interface The existing connector interface doesn’t do very much–it’s just a button that you can click to run the connector. To illustrate how to pass user input data to your connector, let’s add a form so that you can specify the date range for which you want to get earthquake data. Open the earthquakeMultitable.html file, and copy the following code immediately above the &lt;button&gt; element: &lt;h2&gt;Get Earthquake Data for a Time Range&lt;/h2&gt; &lt;form&gt; &lt;div class=\"form-inline\"&gt; &lt;label for=\"start-date-one\" class=\"text-center\"&gt;Start Date&lt;/label&gt; &lt;span&gt;&amp;mdash;&lt;span&gt; &lt;label for=\"end-date-one\"&gt;End Date&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-inline\"&gt; &lt;input type=\"text\" class=\"form-control\" id=\"start-date-one\" value=\"2016-05-08\"&gt; &lt;input type=\"text\" class=\"form-control\" id=\"end-date-one\" value=\"2016-05-15\"&gt; &lt;/div&gt; &lt;/form&gt; This is a simple form with a label and text fields where you can enter date values. Additionally, there are some &lt;div&gt; elements and classes on each element to use Bootstrap styling. If you load the page in a browser, the result looks like this: Store connection data Now that you’ve updated the user interface, it’s time to consume the user input data in the JavaScript code. We’re going to get the values from the input fields and store them in a tableau.connectionData variable for use later. Open the earthquakeMultitable.js file, and replace the $(document).ready function with the following code : $(document).ready(function() { $(\"#submitButton\").click(function() { var dateObj = { startDate: $('#start-date-one').val().trim(), endDate: $('#end-date-one').val().trim(), }; function isValidDate(dateStr) { var d = new Date(dateStr); return !isNaN(d.getDate()); } if (isValidDate(dateObj.startDate) &amp;&amp; isValidDate(dateObj.endDate)) { tableau.connectionData = JSON.stringify(dateObj); tableau.connectionName = \"USGS Earthquake Feed\"; tableau.submit(); } else { $('#errorMsg').html(\"Enter valid dates. For example, 2016-05-08.\"); } }); }); Some things to note about the code: As with the connector in the basic tutorial, the connector uses jquery to run code when the page loads and creates an event listener for the submit button. The values of the date input fields are stored in a date object. (The jquery val() function gets the value of a field, and the trim() function removes spaces.) The isValidDate function takes a string value and determines whether the string is a valid date. The if statement does some simple form validation using the isValidDate function. If the dates are valid, the date object is converted to a string. If the dates are not valid, an error message is displayed in the div with the errorMsg id. The tableau.connectionData variable is the important piece here. It is created by the WDC so that you can pass data to the getSchema and getData functions. It is important to note that the tableau.connectionData variable only accepts string values. Get Multiple Table Schemas In this part of the tutorial, you modify the getSchema code to create two table schemas and pass them to the schemaCallback in an array parameter. Replace the myConnector.getSchema function with the following code: myConnector.getSchema = function(schemaCallback) { // Schema for magnitude and place data var mag_place_cols = [{ id: \"id\", dataType: tableau.dataTypeEnum.string }, { id: \"mag\", alias: \"magnitude\", dataType: tableau.dataTypeEnum.float }, { id: \"title\", alias: \"title\", dataType: tableau.dataTypeEnum.string }, { id: \"lat\", alias: \"latitude\", columnRole: \"dimension\", dataType: tableau.dataTypeEnum.float }, { id: \"lon\", alias: \"longitude\", columnRole: \"dimension\", dataType: tableau.dataTypeEnum.float }]; var magPlaceTable = { id: \"magPlace\", alias: \"Magnitude and Place Data\", columns: mag_place_cols }; // Schema for time and URL data var time_url_cols = [{ id: \"id\", dataType: tableau.dataTypeEnum.string }, { id: \"time\", alias: \"time\", dataType: tableau.dataTypeEnum.date }, { id: \"url\", alias: \"url\", dataType: tableau.dataTypeEnum.string }]; var timeUrlTable = { id: \"timeUrl\", alias: \"Time and URL Data\", columns: time_url_cols }; schemaCallback([magPlaceTable, timeUrlTable]); }; Here’s what’s happening in the code: The mag_place_cols and time_url_cols arrays contain objects for the columns in our tables. The magPlaceTable and timeUrlTable variables each define a table schema object. The table schemas are passed to schemaCallback as objects in an array. Get data for each table When you create multiple table schemas, the WDC API calls the getData function once for each schema. As a result, you need a way to change the call to the USGS Earthquake API for each table. The easiest way to do this is to use the table.tableInfo.id value that we set in the table schemas. Replace the myConnector.getData function with the following code: myConnector.getData = function(table, doneCallback) { var dateObj = JSON.parse(tableau.connectionData), dateString = \"starttime=\" + dateObj.startDate + \"&amp;endtime=\" + dateObj.endDate, apiCall = \"http://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&amp;\" + dateString + \"&amp;minmagnitude=4.5\"; $.getJSON(apiCall, function(resp) { var feat = resp.features, tableData = []; var i = 0; if (table.tableInfo.id == \"magPlace\") { for (i = 0, len = feat.length; i &lt; len; i++) { tableData.push({ \"id\": feat[i].id, \"mag\": feat[i].properties.mag, \"title\": feat[i].properties.title, \"lon\": feat[i].geometry.coordinates[0], \"lat\": feat[i].geometry.coordinates[1] }); } } if (table.tableInfo.id == \"timeUrl\") { for (i = 0, len = feat.length; i &lt; len; i++) { tableData.push({ \"id\": feat[i].id, \"url\": feat[i].properties.url, \"time\": new Date(feat[i].properties.time) // Convert to a date format from epoch time }); } } table.appendRows(tableData); doneCallback(); }); }; Let’s take a look at what’s going on here: The JSON.parse function converts the string value that we stored in the tableau.connectionData variable back to an object. The dateObj object can then be used to access the data that we stored. The dateString variable inserts the start and end dates into a query parameter format expected by the API. The apiCall variable is the URL for our API call. Note that this is a different URL than we used in the basic tutorial. For more information on the query parameters that you can use with this URL, see the Earthquake Catalog API Documentation. We declare the for loop iterator variable i at the top of the function to avoid declaring it twice. We use the table.tableInfo.id to determine which table schema we should use as we push data to the tableData array. Remember that the WDC API makes one call to getData for each table schema. The table.appendRows function adds the array of table data to the table object. See it in action That’s it for the coding part of this tutorial. Time to test your connector in the simulator like you did in the Get Started section and the basic tutorial. When you’re done, try to open your connector in Tableau. Once you open your connector in Tableau, you can drag the Magnitude and Place Data table and the Time and URL Data table to the pane where it says Drag tables here. You can ensure that the tables are joined properly on the id field by clicking the overlapping circles to display the join information. Want to check your work? See the source code in the Examples directory. Now you’re definitely ready to make your own connector! You might also want to learn about incremental refresh and authentication. See the WDC Node.js Proxy with OAuth Tutorial."
                },
            
		
            
                "/webdataconnector/docs/wdc_oauth_tutorial.html": {
                    "title": "WDC Node.js Proxy with OAuth Tutorial",
                    "content": "This tutorial builds on what you learned about web data connectors in the Basic tutorial. Ensure that you understand the concepts in the basic tutorial before you continue. By the end of this tutorial, you’ll have a working WDC that connects to Foursquare and downloads data for sites that you “liked” in Foursquare. This is a multi-step tutorial on how to use OAuth with a Tableau web data connector. Here is a list of all the steps: Introduction and Overview Create a Foursquare App Install and configure the web server Create the UI for Signing In Add Code for OAuth Sign-In Test OAuth Sign-In Get Columns and Data Manage Credentials Test the Connector in the Simulator Test the Connector in Tableau Note: To see all the code for the tutorial, see Complete Code Listing. Step 1 Introduction and Overview In this part of the tutorial, you’ll learn these things: The tutorial scenario. This section describes the web data connector that you’ll build. Prerequisites. What you’ll need, and what we assume you already know about web data connectors. What is OAuth? If you’re new to OAuth, this section provides a quick overview. Which OAuth grant should I use? There are two basic ways to work with OAuth: One uses the implicit grant and client-side flow, and the other uses the authorization code grant and server-side flow. This section provides a brief overview of each and when to use them. The tutorial scenario If you really want to skip all of this and go straight to the source code, look for the foursquare files in the Examples\\OAuthProxyExample directory. However, you’ll get a lot more out of this if you build it yourself following along with this tutorial. Note: The connector that we’ll create in this tutorial (foursquareWDC) has a different name than the same connector in the Examples\\OAuthProxyExample directory (foursquare). This is to minimize the chances of overwriting the existing sample. In this tutorial, you copy some of the files over from the existing sample. These are files that you need to set up the web server. You can adapt this process to create and test new connectors that also require OAuth support. In this tutorial, you’ll build a web data connector that gets data from Foursquare (http://foursquare.com). Foursquare is an app that allows users to search for local services, such as restaurants or attractions. Foursquare also exposes an API that developers can use to perform many of the functions that the app has. Foursquare is one of many sites that use OAuth with their APIs. Others are Facebook, Yelp, Tumblr, Twitter, Spotify, Etsy, and many more. For this tutorial, you’ll create a web data connector that calls the Foursquare venuelikes endpoint, which returns a list of venues that a specific user has “Liked” in Foursquare. When you call the venuelikes endpoint, you must include an OAuth access token. The token tells Foursquare that the user has allowed your app—namely, the web data connector—to access the user’s personal information on Foursquare. Note: This tutorial illustrates how to use OAuth 2.0. Prerequisites To run this tutorial, you need the following: Basic familiarity with JavaScript. The Web Data Connector SDK installed on your computer. Familiarity with the concepts and web data connector example in the Basic tutorial. A web server running locally on your computer and listening on port 3333. In this tutorial, you will use Node.js and Express framework to create a simple web server that will handle the server-side authentication. You can adapt this model to create and test new connectors. We will cover installing and configuring the web server in this tutorial. What is OAuth and how does it work? This section provides some basic information about OAuth for those who are not familiar with it. OAuth is an authentication protocol that allows an application (in our case, a web data connector) to request specific resources from a resource provider (Foursquare) on behalf of a specific resource owner (the user who signs in to Foursquare). This is a more secure and usable alternative to the application asking the user directly for their Foursquare username and password. To use OAuth, an application must be registered with the OAuth resource provider. For example, in this tutorial, you register your application with Foursquare. (If you were using a different OAuth provider, you would register your application with that provider.) The provider assigns a client ID to identify the application and a client secret that is known only by the application and the OAuth provider and is used to authorize the application to make requests on behalf of the user. When the application contacts the OAuth provider, the application passes the client ID to identify itself. The exact process for registering your application differs for each provider, and is typically explained in the provider’s documentation for how to use their API. The following diagram illustrates an example OAuth flow, which is the flow you will build. The steps following the diagram describe the steps in the flow. To connect to data, the end user loads the web data connector in Tableau. The connector displays a button that prompts the user to go to Foursquare to sign in. When the user clicks the button, the connector redirects the user to Foursquare to sign in. (The redirect URL includes the client ID for your connector.) On the Foursquare site, the user signs in and grants permission to the connector to access the user’s personal information. Foursquare redirects the user back to the connector. As part of the URL that redirects the user back to the connector, Foursquare includes an authorization code. The HTTP server we setup with Node.js Express accepts the authorization code and issues a request to Foursquare for an access token. The request includes the client ID and the client secret, a unique identifier that only the server and the Foursquare OAuth provider have knowledge of. The client secret is to ensure that some other application can’t impersonate your connector. Foursquare verifies the authorization code and client secret and returns an access token. The connector includes the access token when it makes requests to Foursquare endpoints. When Foursquare gets the requests, it recognizes that the call is on behalf of the user. Foursquare returns the requested information for the user represented by the access token. Which OAuth grant type should I use? Applications can use OAuth using one of several grant types. A grant type refers to the way an application goes about getting an access token after a user has authorized the application. Two common ones and the ones described here are the authorization code grant and the implicit grant. The grant type you choose determines the type of authorization flow you use. With the authorization code grant, the application requests an authorization code when the user signs in, which is then exchanged for an access token. The authorization code grant can be referred to as server-side flow, as the authorization flow goes through the application’s back end (or server-side) code, which handles exchanging the authorization code and the client secret for the access token. When you use the implicit grant, the application requests the access token, which is returned when the user gives the application permission. This type of grant could be referred to as client-side flow, as the JavaScript that runs in the browser makes the OAuth calls and handles the access token. The primary motivation for using authorization code grant and the server-side flow is to increase security. In client-side flow, all the information required in order to get an access token is on the client—that is, in JavaScript code. This makes the information visible to anyone who can read that JavaScript code. In the server-side flow, the server keeps the client secret that’s assigned to the app, and the secret is used to get the access token. Which should you use? A rule of thumb is that if you’re calling endpoints that require your client secret, you should use the authorization code grant and the server-side flow. The client secret should be kept secure, and the implicit grant and client-side flow potentially exposes the secret. In the server-side flow, the client secret can be kept more secure on the server. We use the authorization code grant and server-side flow in this tutorial. However, if you’re not calling endpoints that require the client secret, it’s generally easier to implement the client-side flow. Step 2 Create a Foursquare App (Back to top) In this part of the tutorial, you’ll create an account with Foursquare (the OAuth provider) and register your app. You’ll get back a client ID and client secret that you’ll need for making calls to Foursquare later. Register your app with Foursquare Before you create the web data connector, you must register your Foursquare application (the web data connector) on the Foursquare developer site. When you’re done, you’ll have a client ID that you use when you communicate with Foursquare and that lets Foursquare know who is making requests. Go to the Foursquare.com site. If you have a Foursquare developer account, sign in. Otherwise, sign up for a new account. Go to the My Apps page (https://foursquare.com/developers/apps) on the Foursquare developer website.{:target=”_blank”} Click the Create a new app button. Fill in the Your app name, Download/welcome page url, and Redirect URI(s) boxes. You can use any values you want for the application name and welcome page URL. For the Redirect URI box, enter the following: http://localhost:3333/redirect You will use this value later on when you make a call to the Foursquare OAuth service. Click Save Changes. Foursquare displays a client ID and a client secret. Copy the client ID and client secret and keep them in a secure location. Note: For this tutorial, you need the client ID and the client secret. The client ID is used for the initial request for authorization. The client secret is used by the local web server to complete the authorization and to obtain the access token. The client secret must be kept secure and away from public view. In this tutorial, we use the client secret on our web server and not in our Foursquare WDC application, where the JavaScript code is potentially accessible. “Like” some venues If you’re new to Foursquare, you don’t have any “Liked” venues. To make sure you have some data to work with later, do this. Go to the Foursquare.com site and sign in. Go to the City Guide, and search for venues and display the listing for a venue that you like. Click the “Like” icon for the venue near the top of the listing. Repeat steps 2 and 3 a few times until you have a selection of “Liked” venues to test later. Next In the next part of the tutorial, you’ll create the folders on your computer where you will host the connector and you will configure the Node.js web server. Step 3 Install and configure the web server (Back to top) In this part of the tutorial, you will create a new directory for your web data connector. You will also copy the Node.js files over from the Examples\\OAuthProxyExampledirectory and then configure the web server to handle the server side OAuth flow, using the client id and client secret you obtained from Foursquare. Create a directory for this foursquare web data connector under the Examples folder (for example, Examples\\FoursquareWDC). Copy the following files: app.js, config.js, and package.json from the Examples\\OAuthProxyExample folder to the folder you just created in step 1. After you copy the three files, create a new folder in your directory called public. You will use this folder later for your connector’s public-facing web page (for example, Examples\\FoursquareWDC\\public). Open a Command or shell window and navigate to the directory where you copied the files (Examples\\FoursquareWDC). Install the express server with the following the following command: npm install The command will install all the files you need to run the web server. Configure the web server. Edit the config.js file in the directory you created and add information about your app. Use http://localhost for the HOSTPATH and the 3333 as the PORT. The REDIRECT_PATH should be /redirect. Your file should look like the following. Replace YOUR_CLIENT_ID and YOUR CLIENT_SECRET with the actual values from Foursquare you saved earlier when you registered your app. // The necessary configuration for your server // Contains credentials for your Foursquare application // And the new redirect path for the OAuth flow module.exports = { 'HOSTPATH': 'http://localhost', 'PORT': 3333, 'CLIENT_ID': 'YOUR_CLIENT_ID', 'CLIENT_SECRET': 'YOUR_CLIENT_SECRET', 'REDIRECT_PATH': '/redirect' }; The information you entered in the config.js file will be used to get the access token from Foursquare. The authorization flow is handled in the web server that you configured, so that the client secret is inaccessible from the public facing web pages that you will create in the next step. Step 4 Create the UI for Signing In (Back to top) In this part of the tutorial, you create an HTML page that contains markup for the UI that lets the user sign in to Foursquare. The HTML page renders the following: You also add JavaScript code that toggles text in the page (“You are signed in” or “You are not signed in”), depending on whether the user is signed in. Get the button graphic The page we are creating uses a graphic for the Connect to Foursquare button. Copy the foursquare_connect.png file from the Examples\\OAuthProxyExample\\public folder and place it in the folder we created for our web page: Examples\\FoursquareWDC\\public. If you create a web data connector for a service that uses OAuth or another authorization method, it is best to use the official buttons and logos from the service. Follow whatever guidance the service recommends regarding the use of trademarks and resources, such as buttons and icons. For this tutorial, we downloaded the graphic from the Foursquare resources page: https://foursquare.com/about/logos. Note that the Foursquare UI for downloading assets might change without notice. Create the HTML markup Create a new file named index.html in the Examples\\FoursquareWDC\\public folder. Then copy the following markup into the new file. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Foursquare Connector&lt;/title&gt; &lt;meta http-equiv=\"Cache-Control\" content=\"no-store\" /&gt; &lt;!-- Latest compiled and minified CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css\"&gt; &lt;!-- Optional theme --&gt; &lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap-theme.min.css\"&gt; &lt;!-- Latest compiled and minified JavaScript --&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;!-- Latest WDC Library --&gt; &lt;script src=\"https://connectors.tableau.com/libs/tableauwdc-2.2.latest.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;!-- Use to access cookie storage to grab access token --&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/js-cookie/2.0.2/js.cookie.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;!-- This will contain all of your OAuth code --&gt; &lt;script src=\"./foursquareWDC.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=\"margin: auto; text-align: center; margin-top: 50px; max-width: 300px\"&gt; &lt;!-- These labels will toggle depending on whether the user is authenticated or not --&gt; &lt;p class=\"signedin\"&gt;You are signed in!&lt;/p&gt; &lt;p class=\"notsignedin\"&gt;You are not signed in, please click below to sign in to your Foursquare account.&lt;/p&gt; &lt;!-- The connect to Foursquare button will have a link added to it in the js--&gt; &lt;a href=\"#\" id=\"connectbutton\"&gt;&lt;img src=\"./foursquare_connect.png\" alt=\"Login with Foursquare\"/&gt;&lt;/a&gt; &lt;br /&gt;&lt;br /&gt; &lt;!-- This button will pull the user's liked venues once the user is authenticated --&gt; &lt;p&gt;&lt;a href=\"#\" class=\"btn btn-primary btn-block\" id=\"getvenuesbutton\"&gt;&lt;span class=\"glyphicon glyphicon-arrow-down\"&gt;&lt;/span&gt; Get Venues I Like&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; At the top of the file, there are &lt;script&gt; elements that link to various libraries: to Twitter Bootstrap, to jQuery, to the Tableau WDC library, and to the foursquareWDC.js library. The Bootstrap and jQuery libraries are optional for web data connectors, but we use them in this tutorial for professional styling (Bootstrap) and to help with some of the JavaScript coding (jQuery). The WDC library (currently tableauwdc-2.2.latest.js) is required for all WDCs. Note: To connect to a web data connector that uses tableauwdc-2.2.latest.js, you must be using a recent version of Tableau. For more information, see Web Data Connector Library Versions. The foursquareWDC.js file is a separate .js file that you’ll create shortly. It will contain all the code for making calls to Foursquare. The page UI consists of a Connect to Foursquare button and a Get Venues I Like button. There is also a single label whose text changes depending on whether the user is authenticated. If you run the page now, both labels are shown. Add code to manage the UI The next task is to add JavaScript that controls the UI in the page. The connector should display one label if the user is signed in, and the other label if not. You also add code that stores the credentials you need later to make calls to Foursquare. In the Examples\\FoursquareWDC\\public folder where the foursquareWDC.html file is, create a file named foursquareWDC.js and copy the following code into it. We will wrap the entire contents of the foursquareWDC.js file in an immediately invoked function expression (IIFE). This adds a measure of security by preventing other linked scripts from accessing secure information inside foursquareWDC.js. (function() { 'use strict'; // This config stores the important strings needed to // connect to the foursquare API and OAuth service to // gain authorization that we then exchange for an access // token. // // Do not store your client secret here. // We are using a server-side OAuth flow, and the client // secret is kept on the web server. var config = { clientId: 'YOUR_CLIENT_ID', redirectUri: 'http://localhost:3333/redirect', authUrl: 'https://foursquare.com/', version: '20190102' }; // more code goes here })(); // end of anonymous function Replace YOUR_CLIENT_ID in the code with the client ID that you got from Foursquare. This is the same client ID that you put in the config.js file when you configured the web server. Use http://localhost:3333/redirect as the value of redirectUri. This is the URL that Foursquare will call after the user has signed in. You can see that the URL includes the path to redirect, meaning that Foursquare will redirect back to our local web server. The web server will field the response and will extract the access token. Notice also that the server name for the URL is localhost:3333, meaning that the redirect will be made to a server running on your computer. If the web data connector is hosted on another server, this URL would have to be changed to reflect that. The authUrl is the Foursquare address where we send the request for authorization. When the user signs in and grants the web data connector access, Foursquare returns an authorization token. Important: The values in the foursquareWDC.js file, including your client ID, could be visible to anyone who can access your web data connector. Don’t put your client secret here. In this tutorial, we are using the authorization code grant type and server-side flow, so the client secret is not embedded in this .js file. The client secret is in the configuration file for the web server that communicates with the OAuth provider. Users of the web data connector never have access to the client secret. Finally, note that the config object contains a version value, which is a date. You must include a version value each time you make a call to Foursquare. For more information about this value, see Versioning &amp; Internationalization on the Foursquare website. Now add the code for managing the UI in the page. Copy the following code and add it to the foursquareWDC.js file below the config object definition. // This function parses the access token in the URI if available // It also adds a link to the foursquare connect button $(document).ready(function() { var accessToken = Cookies.get(\"accessToken\"); var hasAuth = accessToken &amp;&amp; accessToken.length &gt; 0; updateUIWithAuthState(hasAuth); $(\"#connectbutton\").click(function() { doAuthRedirect(); }); $(\"#getvenuesbutton\").click(function() { tableau.connectionName = \"Foursquare Venues Data\"; tableau.submit(); }); }); The document.ready function is jQuery code that runs whenever the page is loaded. The first few lines check to see if the user has already logged in and is already authenticated with the OAuth provider. Because we are handling OAuth using the server-side flow, the server keeps the client secret and handles the required authorization to obtain the access token from Foursquare. The web server can safely pass the access token to our web data connector using browser cookies. The client secret remains secret and unknown to the web data connector. After the authorization state has been checked, the code calls the updateUIWithAuthState function, a function that we will add later, which toggles the visibility of text in the page by setting CSS style attributes for different &lt;p&gt; elements in the page. The next section in our document.ready function links the buttons on the web page to the functions we will add to login to Foursquare (doAuthRedirect()) and create the web data connector (getvenuesbutton()). Step 5 Add Code for OAuth Sign-in (Back to top) In this part of the tutorial, you add JavaScript code that manages the OAuth sign-in process to get authorization. When a user clicks the Connect to Foursquare button, your code redirects the user to Foursquare, where the user can sign in. After the user signs in, Foursquare redirects the user back to the local web server with an authorization code. The web server takes the authorization code and adds the client secret in a request back to Foursquare to get the access token that will be used for making requests for data. Foursquare sends the access token back to the web server. The web server saves the access token in the browser cookie, so that the client code (your web data connector) can retrieve it. You’ll add code to retrieve the OAuth access token from the browser cookie. Add code for initial sign-in First we’ll add the code to enable the user to log in to Foursquare. Add this to your foursquareWDC.js file right after the $(document).ready method and within the anonymous function. // An on-click function for the connect to foursquare button, // This will redirect the user to a foursquare login function doAuthRedirect() { var appId = config.clientId; if (tableau.authPurpose === tableau.authPurposeEnum.ephemerel) { appId = config.clientId; // This should be Desktop } else if (tableau.authPurpose === tableau.authPurposeEnum.enduring) { appId = config.clientId; // This should be the Tableau Server appID } var url = config.authUrl + 'oauth2/authenticate?response_type=code&amp;client_id=' + appId + '&amp;redirect_uri=' + config.redirectUri; window.location.href = url; } You will notice that the first part of the code for the doAuthRedirect() method checks the tableau.authPurpose enum before selecting the client ID to use. The conditional check is because you might have two different client IDs for the web data connector: one for Tableau Desktop and one for Tableau Server. The reason for multiple client IDs is that some OAuth services limit the number of access tokens that can be granted at a time. This is to avoid situations where a Tableau Desktop user who wants to add a web data connector ends up taking an access token away from a web data connector that is used in a workbook on Tableau Server. For more information, see Authentication. The second part of the doAuthRedirect() method builds the URL to send to Foursquare to obtain the authorization code. This request includes the client ID and the redirect URI that are declared in the configuration section of this file. The redirect URI is our local web server http://localhost:3333/redirect. Notice also that the request includes response_type=code. This indicates that the request is for an authorization code. The web server has the client secret and will use the client secret and the authorization code to acquire the access token. Add code to help with the OAuth requests Next, we need to add the code to make the request to Foursquare for the venue data when the user clicks the getvenuesbutton. And we also need to add the code to control which buttons are visible in the UI, depending upon the whether the user is signed in or not. Add the following code after the doAuthRedirect() method. //------------- OAuth Helpers -------------// // This helper function returns the URI for the venueLikes endpoint // It appends the passed in accessToken to the call to personalize the call for the user function getVenueLikesURI(accessToken) { return \"https://api.foursquare.com/v2/users/self/venuelikes?oauth_token=\" + accessToken + \"&amp;v=\" + config.version; } // This function toggles the label shown depending // on whether or not the user has been authenticated function updateUIWithAuthState(hasAuth) { if (hasAuth) { $(\".notsignedin\").css('display', 'none'); $(\".signedin\").css('display', 'block'); } else { $(\".notsignedin\").css('display', 'block'); $(\".signedin\").css('display', 'none'); } } The getVenueLikesURI() method creates the request to Foursquare using the access token that was sent to our local web server as part of the authorization flow. The web server saved the access token in a browser cookie and then redirected the browser back to our web data connector. The presence of the access token is the first thing the web data connector does on page load in the $(document).ready() function. The code that we added also includes the updateUIWithAuthState method that handles the UI state and displays the buttons appropriately depending upon whether the user is signed in to Foursquare or not. The page so far At this point, the foursquareWDC.js file has the following content. (Remember that you must substitute your own client ID in the config object.) (function() { 'use strict'; // This config stores the important strings needed to // connect to the foursquare API and OAuth service to // gain authorization that we then exchange for an access // token. // // Do not store your client secret here. // We are using a server-side OAuth flow, and the client // secret is kept on the web server. var config = { clientId: 'YOUR_CLIENT_ID', redirectUri: 'http://localhost:3333/redirect', authUrl: 'https://foursquare.com/', version: '20190102' }; // This function parses the access token in the URI if available // It also adds a link to the foursquare connect button $(document).ready(function() { var accessToken = Cookies.get(\"accessToken\"); var hasAuth = accessToken &amp;&amp; accessToken.length &gt; 0; updateUIWithAuthState(hasAuth); $(\"#connectbutton\").click(function() { doAuthRedirect(); }); $(\"#getvenuesbutton\").click(function() { tableau.connectionName = \"Foursquare Venues Data\"; tableau.submit(); }); }); // An on-click function for the connect to foursquare button, // This will redirect the user to a foursquare login function doAuthRedirect() { var appId = config.clientId; if (tableau.authPurpose === tableau.authPurposeEnum.ephemerel) { appId = config.clientId; // This should be Desktop } else if (tableau.authPurpose === tableau.authPurposeEnum.enduring) { appId = config.clientId; // This should be the Tableau Server appID } var url = config.authUrl + 'oauth2/authenticate?response_type=code&amp;client_id=' + appId + '&amp;redirect_uri=' + config.redirectUri; window.location.href = url; } //------------- OAuth Helpers -------------// // This helper function returns the URI for the venueLikes endpoint // It appends the passed in accessToken to the call to personalize the call for the user function getVenueLikesURI(accessToken) { return \"https://api.foursquare.com/v2/users/self/venuelikes?oauth_token=\" + accessToken + \"&amp;v=\" + config.version; } // This function toggles the label shown depending // on whether or not the user has been authenticated function updateUIWithAuthState(hasAuth) { if (hasAuth) { $(\".notsignedin\").css('display', 'none'); $(\".signedin\").css('display', 'block'); } else { $(\".notsignedin\").css('display', 'block'); $(\".signedin\").css('display', 'none'); } } })(); // end of anonymous function Next In the next part of the tutorial, you’ll test the Foursquare sign-in process. Step 6 Test OAuth Sign-in (Back to top) You can now test OAuth sign-in by starting the local web server. The web server uses Node.js and the Express framework. You can do this test in the browser without using the simulator that is part of the Web Data Connector SDK. Open a Command Prompt or shell window and go to the folder you created for this tutorial (Examples\\foursquareWDC). Run command: npm start Note: We’re assuming throughout this tutorial that the web server is listening on port 3333 and that the index.html page is in the Examples\\foursquareWDC\\public folder of the WDC SDK installation. Open a browser window and enter the following URL: http://localhost:3333 You see the following in your browser: Click Connect to Foursquare. You see the Foursquare page that prompts you to sign in. Sign in and click Log in and allow. Foursquare redirects you back to the web data connector page in the browser. Note: If you see the message that you are already signed in, you might need to delete cookies from your browsing history. For example, in Chrome, go to Settings, click Advanced, and choose Clear Browsing Data. After you have successfully logged in, if you look in the Command Prompt or shell window where you started the server, you should see something similar to the following. NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Express server listening on port 3333 Auth Code is: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA accessToken: BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB When the Express web server starts up, it prints the client ID and the client secret to the console and then listens on port 3333. When the user signs in to Foursquare and grants permission to share data with the web data connector, Foursquare redirects the browser back to the web server with the authorization code. The web server prints out the authorization code and the access token when the authorization process is successful. The connector is now authorized to read your Foursquare info. Next In the next Step of the tutorial, you’ll add the code that runs during the data-gathering phase of the web data connector to get the schema and the data. Step 7 Get Columns and Data (Back to top) So far, all the code you’ve added was for getting the OAuth authorization code and the access token. In this part of the tutorial you’ll add the JavaScript code that all web data connectors have—code to get the schema (field names and types) for the data, and to get the data itself. This code is similar to the equivalent code in the basic tutorial. Add code to get columns and data Copy the following code into the bottom of the foursquareWDC.js file. //------------- Tableau WDC code -------------// // Create tableau connector, should be called first var myConnector = tableau.makeConnector(); // Declare the data to Tableau that we are returning from Foursquare myConnector.getSchema = function(schemaCallback) { var schema = []; var col1 = { id: \"Name\", dataType: \"string\"}; var col2 = { id: \"Latitude\", dataType: \"float\"}; var col3 = { id: \"Longitude\", dataType: \"float\"}; var col4 = { id: \"Address\", dataType: \"string\"}; var cols = [col1, col2, col3, col4]; var tableInfo = { id: \"FoursquareTable\", columns: cols } schema.push(tableInfo); schemaCallback(schema); }; // This function actually make the foursquare API call and // parses the results and passes them back to Tableau myConnector.getData = function(table, doneCallback) { var dataToReturn = []; var hasMoreData = false; var accessToken = tableau.password; var connectionUri = getVenueLikesURI(accessToken); var xhr = $.ajax({ url: connectionUri, dataType: 'json', success: function (data) { if (data.response) { var venues = data.response.venues.items; var ii; for (ii = 0; ii &lt; venues.length; ++ii) { var venue = {'Name': venues[ii].name, 'Latitude': venues[ii].location.lat, 'Longitude': venues[ii].location.lng, 'Address' : venues[ii].location.address}; dataToReturn.push(venue); } table.appendRows(dataToReturn); doneCallback(); } else { tableau.abortWithError(\"No results found\"); } }, error: function (xhr, ajaxOptions, thrownError) { // WDC should do more granular error checking here // or on the server side. This is just a sample of new API. tableau.abortForAuth(\"Invalid Access Token\"); } }); }; // Register the tableau connector, call this last tableau.registerConnector(myConnector); The code you copied and added to the file follows the same outline as other web data connectors. The code starts by calling tableau.makeConnector to create an instance of the connector. It then adds code to define the data schema (getSchema) and to actually fetch the data (getData). When the connector is completely configured, the code calls tableau.registerConnector. In this tutorial, the getSchema function defines four fields and corresponding data types. The getData function is similar to the one from the basic tutorial. The code calls the helper function we added earlier (getVenueLikesURI) to create the request URI, and then uses jQuery to make an AJAX call to the data source. When the data is returned, a function in the success parameter parses the data, creates JavaScript objects out of each returned value, and then calls the doneCallback function to send the data to Tableau. One difference from the other two WDC tutorials is that this time the getData function contains these lines: var accessToken = tableau.password; var connectionUri = getVenueLikesURI(accessToken); When the getData function sends a request to Foursquare, the URL of the request has to include the access token. You might remember from the Multiple Tables Tutorial that you can use the tableau.connectionData property to pass values from the interactive (UI) phase of the connector to the data-gathering phase. (Because the phases run in separate browser sessions, you can’t use other mechanisms to share values between the phases.) In the Multiple Tables tutorial, you use tableau.connectionData to pass the date object that contains the start and end dates between phases. When you’re using OAuth, you have the same issue with the access token—you gather it from the user authorization flow in the interactive phase, but you need to use it in the data-gathering phase. You can use the tableau.password property for this purpose. It’s designed specifically for sensitive information like passwords or access tokens. The tableau.password property, like tableau.connectionData, allows you to pass values between phases of the connector. However, you should never use tableau.connectionData for sensitive information like passwords or access tokens. Although the code includes a function to extract the access token, you haven’t set the value of the tableau.password yet. You’ll do that shortly. Step 8 Manage Credentials (Back to top) In this part of the tutorial, you add code to make sure that the connector has an OAuth access token before it makes requests to Foursquare. If the access token is not available, you display UI in the connector to let the user sign in again. You’ll learn about the following: Persisting credentials in the tableau.username property. The authorization and authentication (auth) phase of the connector, which occurs if Tableau needs credentials in order to refresh an extract. Sidebar: Credentials in web data connectors Before you start this part of the tutorial, it’s helpful to review how Tableau manages credentials when a user works with a web data connector in Tableau. If a connector requires basic authentication, you add markup and code to get credentials from the user. When the user loads the web data connector into Tableau, the connector goes through its interactive phase (UI phase) and uses your UI to gather information and credentials from the user. When you store parameter information in the tableau.connectionData property, you store any user credentials in the tableau.username and tableau.password properties. For OAuth authentication, the process is slightly different, depending upon whether you are using server-side or client-side flow and are using an authorization token and client secret to acquire the access token. In either case, the goal is to end up with an access token you can use to make requests on behalf of the user. For OAuth, you store the access token in the tableau.password property. When the user finishes entering information and credentials, in basic authentication, or finishes the authentication phase with the OAuth provider, Tableau loads the connector again and the connector goes through its data-gathering phase. In that phase, Tableau calls the connector’s getSchema and getData functions. When these functions make calls to the data source, they can get the OAuth access token from the tableau.password property and use it when constructing requests to fetch data. While the user is working in Tableau, the value in the tableau.password property is not persisted between sessions. Therefore, if the user closes Tableau, re-opens it, and re-loads a workbook that uses the web data connector, Tableau doesn’t have the access token. Specifically, there’s no value in the tableau.password property. In that case, Tableau calls the connector just to get the credentials again. This is referred to as the authentication phase or auth phase. For connectors that simply get the username and password (such as a connector that accesses a data source like SQL Server), Tableau can display a standard sign-in UI. However, Tableau has no built-in UI for OAuth. Therefore, Tableau has to tell your connector to display the UI that you’ve created to redirect the user sign in to the OAuth provider. In the auth phase, the connector should display only the UI that’s required in order to get the user’s credentials. In this phase, the connector doesn’t need to ask the user for any other information, such as query parameter values. (In fact, in the auth phase, Tableau ignores any changes that you make except those to the tableau.username and tableau.password properties.) To determine whether your connector is being loaded in auth phase, you can test the tableau.phase property. The following example shows how you can determine what phase the connector is in. if (tableau.phase == tableau.phaseEnum.authPhase) { // Display OAuth authentication UI } Manage credentials during the data-gathering phase Because you’re using OAuth, you have to include custom initialization logic—that is, you have to include a tableau.init function in your web data connector code. (For web data connectors that don’t use OAuth, the Web Data Connector .js library provides a default init function, so you only need to create an init function if you need to add custom initialization code.) After the call to tableau.makeConnector and before myConnector.getSchema, add the following code: // add this after tableau.makeConnector() function. // Init function for connector, called during every phase but // only called when running inside the simulator or tableau myConnector.init = function(initCallback) { tableau.authType = tableau.authTypeEnum.custom; // If we are in the auth phase we only want to show the UI needed for auth if (tableau.phase == tableau.phaseEnum.authPhase) { $(\"#getvenuesbutton\").css('display', 'none'); } if (tableau.phase == tableau.phaseEnum.gatherDataPhase) { // If the API that WDC is using has an endpoint that checks // the validity of an access token, that could be used here. // Then the WDC can call tableau.abortForAuth if that access token // is invalid. } var accessToken = Cookies.get(\"accessToken\"); console.log(\"Access token is '\" + accessToken + \"'\"); var hasAuth = (accessToken &amp;&amp; accessToken.length &gt; 0) || tableau.password.length &gt; 0; updateUIWithAuthState(hasAuth); initCallback(); // If we are not in the data gathering phase, we want to store the token // This allows us to access the token in the data gathering phase if (tableau.phase == tableau.phaseEnum.interactivePhase || tableau.phase == tableau.phaseEnum.authPhase) { if (hasAuth) { tableau.password = accessToken; if (tableau.phase == tableau.phaseEnum.authPhase) { // Auto-submit here if we are in the auth phase tableau.submit() } return; } } }; // The myConnector.getSchema() goes here Code explanation The connector’s init function is called each time that the connector is loaded. This gives the connector an opportunity to perform any initialization that the connector requires in each phase. In the init function, we set the tableau.authType to custom, so that we can setup the OAuth flow in the WDC auth phase. The auth phase is similar to the interactive phase. You can determine what phase is active by testing the tableau.phase property. In this connector, one task for the init function is to get the access token from the page cookies. As you’ve already seen, during the interactive phase, the connector redirects to Foursquare, and Foursquare redirects back to the proxy web server using a URL that includes the authorization token. The proxy web server the sends the authorization token along with the client secret to Foursquare. Foursquare responds by returning the access token in the response. Our Node.js Express web server sets the access token in a client cookie. When the connector is loaded again for the data-gathering phase, the page checks the validity of the access token before proceeding. If the access token is valid and the connector has authorization (hasAuth), the connector saves the access token in tableau.password property. This makes the access token available to the getData function for the data-gathering phase. Another task for the init code is to display the appropriate UI for the phase that the connector is in, or to test the validity of the access token. These are the conditions: If the user is not signed in to Foursquare, the text “You are not signed in” should be displayed. This is handled with a call to the updateUIWithAuthState helper function that we added to the file earlier. Optionally, call the tableau.abortForAuth method. This method is provided for cases where the access token has expired or has been revoked. The tableau.abortForAuth method must be called from the init method during the gather data phase. Some APIs provide an endpoint for testing the validity of the access token. In that scenario, before fetching data, the WDC would want to call this method in order to re-authenticate the user. See Authentication. If the connector is in its interactive phase and if the user is not yet signed in, the Get Venues I Like button should be hidden—this button is useful only after the user is signed in. Similarly, if the connector is in its auth phase, the only UI that the page should display is the button that lets the user sign in. In this tutorial, this also consists of hiding the Get Venues I Like button. You might recognize some of this logic from the document.ready function that you added earlier in the tutorial, where we also call the updateUIWithAuthState helper function. This allows you to work with the connector in a browser, which is useful for testing in the simulator, as we’ll explain in the next part of the tutorial. As in any web data connector, when the user has finished interacting with the page, your code sets tableau object properties like connectionName and connectionData (if required), and calls tableau.submit to tell Tableau that the interactive phase is done. One difference in this init function, is that when the user has been authenticated, we store the access token in tableau.password. line: tableau.password = accessToken; Step 9 Test the Connector in the Simulator (Back to top) In this part of the tutorial, you’ll test the finished connector in the simulator that’s part of the Web Data Connector SDK. Test the finished connector in the simulator You can now test the web data connector in the simulator. If you haven’t done so already, you need to follow the steps in Getting Started to install the components needed to run the simulator. Open a Command Prompt or shell window and navigate to the webdataconnector folder. This is the top-level folder if you downloaded or cloned the WDC repository. If you haven’t done so already, start the web server that runs the simulator. npm start Start the simulator by entering the following in your browser: localhost:8888/simulator/ (As before, we’re assuming that the server is listening on port 8888.) In the WDC URL box at the top of the simulator, enter the path to the foursquare connector: ../Examples/foursquareWDC/public Click the Start Interactive Phase button. The simulator opens a window and displays the UI for the Foursquare web data connector. If the page indicates that you’re not logged in to Foursquare, click the Connect to Foursquare button and log in. After you have logged in, click the Get Venues I Like button. The simulator closes the window that displayed the UI phase of the connector and returns to the main simulator window. At the bottom of the main simulator window, the simulator displays the column names and the types for the table schema you defined. Click Fetch Table Data to display the values for any venues that you’ve “Liked” on Foursquare. Notice also that the simulator has filled the Password box with the authentication token. Remember that in your code, when you got the authentication token back from Foursquare, you set the tableau.password property to the token value. When you run the simulator, after the UI phase is done, the simulator displays the values of tableau object properties. Note: If you see the message that you are already signed in, and you want to test the sign in process, you might need to delete cookies from your browsing history. For example, in Chrome, go to Settings, click Advanced, and choose Clear Browsing Data. Step 10 Test the Connector in Tableau (Back to top) In this final part of the tutorial, you’ll use your connector in Tableau to display a map that includes locations that you’ve “Liked” in Foursquare. Test in Tableau The OAuth Foursquare web data connector is complete! You can now test it in Tableau. Make sure you have “Liked” at least a few venues on Foursquare, or you won’t have any data to view in Tableau. Open Tableau. In the Connect pane, under To a Server, choose Web Data Connector. You might need to choose More… to find it. Enter the URL of your connector (http://localhost:3333). Click the Connect to Foursquare button and sign in. In the connector, click Get Venues I Like. The connector creates an extract that contains information about the venues you have liked on Foursquare, and Tableau opens a workbook that uses the extract. To see what the data looks like in Tableau, do this: Drag Longitude to the Columns shelf. Drag Latitude to the Rows shelf. Drag Name to Label in the Marks card. Drag Address to Details in the Marks card. The viz displays a map that shows places you’ve “Liked.” Complete Code Listing (Back to top) This page provides complete code listings (foursquareWDC.html and foursquareWDC.js) for the web data connector Node Proxy OAuth client tutorial (app.js and config.js). FoursquareWDC.html page Note: This listing includes a reference to the tableauwdc-2.2.latest.js To connect to a web data connector that uses that version of the WDC library, you must be using a recent version of Tableau. For more information, see Web Data Connector Library Versions. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Foursquare Connector&lt;/title&gt; &lt;meta http-equiv=\"Cache-Control\" content=\"no-store\" /&gt; &lt;!-- Latest compiled and minified CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css\"&gt; &lt;!-- Optional theme --&gt; &lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap-theme.min.css\"&gt; &lt;!-- Latest compiled and minified JavaScript --&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;!-- Latest WDC Library --&gt; &lt;script src=\"https://connectors.tableau.com/libs/tableauwdc-2.2.latest.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;!-- Use to access cookie storage to grab access token --&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/js-cookie/2.0.2/js.cookie.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;!-- This will contain all of your OAuth code --&gt; &lt;script src=\"./foursquareWDC.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=\"margin: auto; text-align: center; margin-top: 50px; max-width: 300px\"&gt; &lt;!-- These labels will toggle depending on whether the user is authenticated or not --&gt; &lt;p class=\"signedin\"&gt;You are signed in!&lt;/p&gt; &lt;p class=\"notsignedin\"&gt;You are not signed in, please click below to sign in to your Foursquare account.&lt;/p&gt; &lt;!-- The connect to Foursquare button will have a link added to it in the js--&gt; &lt;a href=\"#\" id=\"connectbutton\"&gt;&lt;img src=\"./foursquare_connect.png\" alt=\"Login with Foursquare\"/&gt;&lt;/a&gt; &lt;br /&gt;&lt;br /&gt; &lt;!-- This button will pull the user's liked venues once the user is authenticated --&gt; &lt;p&gt;&lt;a href=\"#\" class=\"btn btn-primary btn-block\" id=\"getvenuesbutton\"&gt;&lt;span class=\"glyphicon glyphicon-arrow-down\"&gt;&lt;/span&gt; Get Venues I Like&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; FoursquareWDC.js (function() { 'use strict'; // This config stores the important strings needed to // connect to the foursquare API and OAuth service to // gain authorization that we then exchange for an access // token. // // Do not store your client secret here. // We are using a server-side OAuth flow, and the client // secret is kept on the web server. var config = { clientId: 'YOUR_CLIENT_ID', redirectUri: 'http://localhost:3333/redirect', authUrl: 'https://foursquare.com/', version: '20190102' }; // more code goes here // This function parses the access token in the URI if available // It also adds a link to the foursquare connect button $(document).ready(function() { var accessToken = Cookies.get(\"accessToken\"); var hasAuth = accessToken &amp;&amp; accessToken.length &gt; 0; updateUIWithAuthState(hasAuth); $(\"#connectbutton\").click(function() { doAuthRedirect(); }); $(\"#getvenuesbutton\").click(function() { tableau.connectionName = \"Foursquare Venues Data\"; tableau.submit(); }); }); // An on-click function for the connect to foursquare button, // This will redirect the user to a foursquare login function doAuthRedirect() { var appId = config.clientId; if (tableau.authPurpose === tableau.authPurposeEnum.ephemerel) { appId = config.clientId; // This should be Desktop } else if (tableau.authPurpose === tableau.authPurposeEnum.enduring) { appId = config.clientId; // This should be the Tableau Server appID } var url = config.authUrl + 'oauth2/authenticate?response_type=code&amp;client_id=' + appId + '&amp;redirect_uri=' + config.redirectUri; window.location.href = url; } //------------- OAuth Helpers -------------// // This helper function returns the URI for the venueLikes endpoint // It appends the passed in accessToken to the call to personalize the call for the user function getVenueLikesURI(accessToken) { return \"https://api.foursquare.com/v2/users/self/venuelikes?oauth_token=\" + accessToken + \"&amp;v=\" + config.version; } // This function toggles the label shown depending // on whether or not the user has been authenticated function updateUIWithAuthState(hasAuth) { if (hasAuth) { $(\".notsignedin\").css('display', 'none'); $(\".signedin\").css('display', 'block'); } else { $(\".notsignedin\").css('display', 'block'); $(\".signedin\").css('display', 'none'); } } //------------- Tableau WDC code -------------// // Create tableau connector, should be called first var myConnector = tableau.makeConnector(); // Init function for connector, called during every phase but // only called when running inside the simulator or tableau myConnector.init = function(initCallback) { tableau.authType = tableau.authTypeEnum.custom; // If we are in the auth phase we only want to show the UI needed for auth if (tableau.phase == tableau.phaseEnum.authPhase) { $(\"#getvenuesbutton\").css('display', 'none'); } if (tableau.phase == tableau.phaseEnum.gatherDataPhase) { // If API that WDC is using has an endpoint that checks // the validity of an access token, that could be used here. // Then the WDC can call tableau.abortForAuth if that access token // is invalid. } var accessToken = Cookies.get(\"accessToken\"); console.log(\"Access token is '\" + accessToken + \"'\"); var hasAuth = (accessToken &amp;&amp; accessToken.length &gt; 0) || tableau.password.length &gt; 0; updateUIWithAuthState(hasAuth); initCallback(); // If we are not in the data gathering phase, we want to store the token // This allows us to access the token in the data gathering phase if (tableau.phase == tableau.phaseEnum.interactivePhase || tableau.phase == tableau.phaseEnum.authPhase) { if (hasAuth) { tableau.password = accessToken; if (tableau.phase == tableau.phaseEnum.authPhase) { // Auto-submit here if we are in the auth phase tableau.submit() } return; } } }; // Declare the data to Tableau that we are returning from Foursquare myConnector.getSchema = function(schemaCallback) { var schema = []; var col1 = { id: \"Name\", dataType: \"string\"}; var col2 = { id: \"Latitude\", dataType: \"float\"}; var col3 = { id: \"Longitude\", dataType: \"float\"}; var col4 = { id: \"Address\", dataType: \"string\"}; var cols = [col1, col2, col3, col4]; var tableInfo = { id: \"FoursquareTable\", columns: cols } schema.push(tableInfo); schemaCallback(schema); }; // This function actually make the foursquare API call and // parses the results and passes them back to Tableau myConnector.getData = function(table, doneCallback) { var dataToReturn = []; var hasMoreData = false; var accessToken = tableau.password; var connectionUri = getVenueLikesURI(accessToken); var xhr = $.ajax({ url: connectionUri, dataType: 'json', success: function (data) { if (data.response) { var venues = data.response.venues.items; var ii; for (ii = 0; ii &lt; venues.length; ++ii) { var venue = {'Name': venues[ii].name, 'Latitude': venues[ii].location.lat, 'Longitude': venues[ii].location.lng, 'Address' : venues[ii].location.address}; dataToReturn.push(venue); } table.appendRows(dataToReturn); doneCallback(); } else { tableau.abortWithError(\"No results found\"); } }, error: function (xhr, ajaxOptions, thrownError) { // WDC should do more granular error checking here // or on the server side. This is just a sample of new API. tableau.abortForAuth(\"Invalid Access Token\"); } }); }; // Register the tableau connector, call this last tableau.registerConnector(myConnector); })(); // end of anonymous function Config.js Configuration file for Node.js Express web server. // The necessary configuration for your server // Contains credentials for your Foursquare application // And the new redirect path for the OAuth flow module.exports = { 'HOSTPATH': 'http://localhost', 'PORT': 3333, 'CLIENT_ID': 'YOUR_CLIENT_ID', 'CLIENT_SECRET': 'YOUR_CLIENT_SECRET', 'REDIRECT_PATH': '/redirect' }; app.js Express web server, using Node.js. // -------------------------------------------------- // // Module Dependencies // -------------------------------------------------- // var express = require('express'); var cookieParser = require('cookie-parser'); var querystring = require('querystring'); var http = require('http'); var request = require('request'); var path = require('path'); var config = require('./config.js'); // Get our config info (app id and app secret) var sys = require('util'); var app = express(); // -------------------------------------------------- // // Express set-up and middleware // -------------------------------------------------- // app.set('port', (process.env.PORT || config.PORT)); app.use(cookieParser()); // cookieParser middleware to work with cookies app.use(express.static(__dirname + '/public')); // -------------------------------------------------- // // Variables // -------------------------------------------------- // var clientID = process.env.FOURSQUARE_CLIENT_ID || config.CLIENT_ID; var clientSecret = process.env.FOURSQUARE_CLIENT_SECRET || config.CLIENT_SECRET; console.log(clientID); console.log(clientSecret); var redirectURI = config.HOSTPATH + \":\" + config.PORT + config.REDIRECT_PATH // -------------------------------------------------- // // Routes // -------------------------------------------------- // app.get('/', function(req, res) { console.log(\"got here\"); res.redirect('/index.html'); }); // This route is hit once Foursquare redirects to our // server after performing authentication app.get('/redirect', function(req, res) { // get our authorization code authCode = req.query.code; console.log(\"Auth Code is: \" + authCode); // Set up a request for an long-lived Access Token now that we have a code var requestObject = { 'client_id': clientID, 'redirect_uri': redirectURI, 'client_secret': clientSecret, 'code': authCode, 'grant_type': 'authorization_code' }; var token_request_header = { 'Content-Type': 'application/x-www-form-urlencoded' }; // Build the post request for the OAuth endpoint var options = { method: 'POST', url: 'https://foursquare.com/oauth2/access_token', form: requestObject, headers: token_request_header }; // Make the request request(options, function (error, response, body) { if (!error) { // We should receive { access_token: ACCESS_TOKEN } // if everything went smoothly, so parse the token from the response body = JSON.parse(body); var accessToken = body.access_token; console.log('accessToken: ' + accessToken); // Set the token in cookies so the client can access it res.cookie('accessToken', accessToken, { }); // Head back to the WDC page res.redirect('/index.html'); } else { console.log(error); } }); }); // -------------------------------------------------- // // Create and start our server // -------------------------------------------------- // http.createServer(app).listen(app.get('port'), function(){ console.log('Express server listening on port ' + app.get('port')); }); (Back to top)"
                },
            
		
            
                "/webdataconnector/docs/wdc_phases.html": {
                    "title": "WDC Lifecycle and Phases",
                    "content": "This document explains the overall lifecycle of a Tableau Web Data Connector. It is recommended that you understand the material from the Get Started section before diving into this material. A WDC is always run with an associated phase. Tableau loads the connector inside a web browser at different times and in distinct phases. This document will explain each of these phases and when each one runs. Lifecycle diagram At a high level, the WDC lifecycle is as follows: Note: This is slightly simplified. For example, shutdown and shutdownCallback were left out, but both of these events take place at the end of each phase as well (they mirror init and initCallback). Interactive phase: Interact with the user Tableau launches the web data connector in the interactive phase. This could be Tableau Desktop, or the Simulator. In the interactive phase, the following actions occur: The connector’s init method is called by Tableau. A connector will have a default init method if not provided by the WDC Developer (see Custom Initialization and Shutdown for more details). The connector calls the passed in initCallback to tell Tableau it has finished initialization. The connector waits for interaction to be completed by the end user. This could entail waiting for the user to authenticate, waiting for the user to enter some sort of data in a form, and more. This is optional, if a connector has no need for user input, it can call submit() immediately. The connector calls the function tableau.submit(), which tells Tableau that the connector is ready to finish the interactive phase. Gather data phase: Fetch data from a web source After the interactive phase has been completed, Tableau will launch the web data connector in a new, headless (meaning without UI) browser session. The connector will now be in the gather data phase. This phase can be launched from Tableau Desktop, Tableau Server, Tableau Online, or the Simulator. In the gather data phase, the following actions occur: The connector’s init method is called by Tableau, just as it was in the interactive phase. The connector may want to take different action in the init method in the gather data phase than it did in the interactive phase. At any time, the current phase of the connector can be read through the tableau.phase property. The connector calls the passed in initCallback to tell Tableau it has finished initialization. Tableau first calls the getSchema method, which you define for your connector to map web data to table columns in Tableau. The connector will call schemaCallback with a schema object, which passes the connector’s schema back to Tableau. Tableau then calls the getData method of the connector to get the actual data. The getData method will be called by Tableau once for each table that has been selected by the end user. For example, if a user drags out two tables from the web data connector into the join canvas in Tableau, getData will be called twice. The getData method receives a table object as a parameter. In the getData method, the WDC needs to fetch data for that specific table from the web data source, and use the table.appendRows method to pass data for that table back to Tableau. Once all the data has been fetched for the current table, the WDC should call the passed in dataDoneCallback(). At this point, Tableau will go back and call getData for another table if necessary. If not, the WDC flow is completed and data can now be analyzed within Tableau. Note: For connectors with multiple tables, there is no deterministic order for the calls to the getData method. However, the base table in a join (the top and leftmost table) will always have its getData method called first. Authentication phase: Display authentication UI when needed The authentication phase is an optional phase which Tableau uses to refresh extracts that require authentication. Rather than reload the connector and get the schema again, Tableau runs the authentication phase to only display the user interface required for authentication. Note: This is not really a third phase, because it does not follow the other two; it’s an alternative to the first phase. In this mode, the connector should display only the UI that is required in order to get an updated token. Updates to properties other than tableau.username and tableau.password will be ignored during this phase. For more information, on how to use the authentication phase, see WDC Authentication. Pass data between phases Often it is necessary to pass data from one phase to another. For example, you might want to store user input from the interaction phase and use the input in the get data phase to build personalized requests to an API. You can store data that you want to pass between phases using the tableau.connectionData property. The property can only store data as a string, so if you want to store JavaScript objects, you must serialize and deserialize the data. For example, to store a JavaScript object as a string, you might run the following code: tableau.connectionData = JSON.stringify(example_data); Then, to convert the string back into a JavaScript object, you might run the following code: JSON.parse(tableau.connectionData); For an example of how you might use this in a web data connector, see the Multiple Tables Tutorial."
                },
            
		
            
                "/webdataconnector/docs/wdc_ref_date_formats.html": {
                    "title": "Supported Date Formats",
                    "content": "Web data connectors can work with Date and DateTime values that use the following formats: dd-MM-yyyy dd-MMM dd-MMM-yy dd-MMM-yyyy dd-MMM-yyyy HH:mm:ss dd/MM/yyyy h:mm a HH.mm hh.mm a HH.mm.ss hh.mm.ss a hh:mm a HH:mm:ss hh:mma M/d/yyyy HH:mm:ss MM-dd-yyyy MM-dd-yyyy HH:mm MM/dd/yy MM/dd/yy HH:mm:ss MM/dd/yyyy MM/dd/yyyy MM/dd/yyyy HH:mm:ss MM/dd/yyyy hh:mm:ss a MMM yyyy MMM-yy MMMM dd yyyy MMMM dd yyyy hh:mma MMMM dd, yyyy MMMM dd, yyyy HH:mm:ss MMMM dd,yyyy MMMM dd,yyyy HH:mm:ss yyyy-MM-dd yyyy-MM-dd HH:mm yyyy-MM-dd HH:mm:ss yyyy-MM-dd HH:mm:ss.SSS yyyy-MM-dd HH:mm:ss.SSS yyyy-MM-dd HH:mm:ss.SSS yyyy/MM/dd yyyy/MM/dd HH:mm:ss For information about the symbols used in these format examples, see Formatting Dates and Times on the ICU User Guide site."
                },
            
		
            
                "/webdataconnector/docs/wdc_resources.html": {
                    "title": "Developer Resources",
                    "content": "New to web development? Start here: JavaScript First Steps. A gentle introduction to JavaScript from the Mozilla Developer Network. A Survey of the JavaScript Programming Language. An introduction to JavaScript for existing programmers by Douglas Crockford. Chrome Developer Tools. The documentation for the Chrome Developer Tools to help you create and debug connectors. npm Documentation. The documentation for node package manager (npm), which is used by the web data connector SDK. Here are some helpful resources for WDC development: WDC Generator. A scaffolding tool for Tableau Web Data Connectors, built on yeoman. Community Portal. Learn from existing open source connectors on our community portal. Samples. Learn from the WDC samples. Community Forums. Learn from the community in the forums."
                },
            
		
            
                "/webdataconnector/docs/wdc_samples.html": {
                    "title": "WDC Samples",
                    "content": "The Web Data Connector comes with sample connectors that you can use to learn about specific features of the WDC API. The samples are in the Examples folder of the webdataconnector repository. You can see the repository online here. earthquakeUSGS This is the default connector when you open the simulator. Instructions for building it are in the Tutorial. It connects to the USGS Earthquake feed and gets data about earthquakes in the last week. earthquakeMultitable This connector builds on the previous one to showcase how to get data into multiple tables from a data source. earthquakeMultilingual This connector demonstrates how to use the locale property of the tableau object to localize content. StandardConnections This connector gets data from multiple tables in a local JSON file and specifies how the tables should be joined in Tableau Desktop. IncrementalRefreshConnector This connector showcases how use the incremental refresh API to fetch data incrementally. OAuthProxyExample This example shows you how to use OAuth as an authentication method."
                },
            
		
            
                "/webdataconnector/docs/wdc_standard_connections.html": {
                    "title": "Standard Connections",
                    "content": "When you create a web data connector that gets data from multiple tables, you can pre-specify how you want to join the tables in Tableau Desktop. Tableau Desktop supports left and inner joins for web data connectors. Before you create a standard connection, ensure that you have a working web data connector for your tables. For more information on getting data from multiple tables, see the Multiple Tables Tutorial. Once you have a working connector for multiple tables, complete the following steps to create and use standard connections: Important: Standard connections are only supported in WDC versions 2.1 and later. Create the connection objects For every set of tables in a web data connector that you want to join, you need to create a connection object. A connection object is a JavaScript object that specifies the tables that you want to join, the columns that you want to use to join the tables, and the type of join. For example, you could use the following connection object to join the tables from the sample created in the Multiple Tables Tutorial. var standardConnection = { \"alias\": \"Joined earthquake data\", \"tables\": [{ \"id\": \"magPlace\", \"alias\": \"Magnitude and Place\" }, { \"id\": \"timeUrl\", \"alias\": \"Time and URL\" }], \"joins\": [{ \"left\": { \"tableAlias\": \"Magnitude and Place\", \"columnId\": \"id\" }, \"right\": { \"tableAlias\": \"Time and URL\", \"columnId\": \"id\" }, \"joinType\": \"inner\" }] }; The connection object includes the following properties: alias. This is the name of the connection as it appears in Tableau Desktop. tables. The tables that you want to join. For example, in the above connection object there is a table named magPlace and a table named `timeUrl. It is important to note that the first table in the array must always be the left-most table in the join. joins. An array which includes the following properties: left and right. Defines which tables you want to appear on the left and right side in Tableau Desktop. The order of the tables impacts the resulting joined data and is especially important if you use a left join or include more than two tables. joinType. The type of join. Use an inner join to display only the rows of data that are in both tables. Use a left join to display all the rows that are in the left table and the matching rows that are in the right table. For more information on joins, see Join Your Data in the Tableau Desktop help. Pass connection objects to the schemaCallback function The schemaCallback function takes an array of connection objects as a second parameter. (For connectors that do not include standard connections, you do not need to include this second parameter.) For example, to pass the sample connection object created above to Tableau, enter the following parameters: schemaCallback([magPlaceTable, timeUrlTable], [connectionObject]); You can include multiple connection objects in the array. Use your standard connections in the simulator To use a standard connection in the simulator, complete the following steps: Start the simulator. Enter the URL for your connector in the Connector URL field. Click the Show Advanced button to display the Standard Connections interface. Click the Start Interactive Phase button. Interact with your connector until you are returned to the simulator. Optionally, click the Joins tab in the Standard Connections interface to view a diagram of your standard connection. Use your standard connections in Tableau To use a standard connection in Tableau, complete the following steps: Open your connector and complete the interactive phase. Drag your connection from the Standard Connection pane on the left to the Tables pane in the upper right. The joined tables appear in the Tables pane."
                },
            
		
            
                "/webdataconnector/docs/wdc_tutorial.html": {
                    "title": "WDC Tutorial",
                    "content": "This tutorial picks up where the Get Started topic left off. If you haven’t already, go back and set up your development environment. By the end of this tutorial, you’ll have a working WDC that connects to the USGS Earthquake feed and downloads data for earthquakes that occurred in the last week. You’ll learn how to: If you really want to skip all of this and go straight to the source code, look for the earthquakeUSGS files in the Examples directory. You’ll get a lot more out of this if you build it from scratch though–promise! Note: The connector that we’ll create in this tutorial (earthquakeWDC) has a different name than the same connector in the Examples directory (earthquakeUSGS). This is to minimize the chances of accidentally overwriting the existing sample. However, if you copy the existing sample, you’ll have to change file paths. Note: The browser used inside Tableau Desktop 2019.3 and earlier is QT WebKit, which does not natively support new ES6 features. If you wish to take advantage of newer features (such as promises) when building WDCs for older versions of Tableau you will need to use a polyfill. Create the HTML page When you open a WDC in Tableau, you display an HTML page that links to your JavaScript code and to the WDC library. Optionally, this page can also display a user interface for your users to select the data that they want to download. Create a new file named earthquakeWDC.html and save it in the top-level directory of the webdataconnector repository. (This is the same directory as the README.) Then, copy the following code into the file: &lt;html&gt; &lt;head&gt; &lt;title&gt;USGS Earthquake Feed&lt;/title&gt; &lt;meta http-equiv=\"Cache-Control\" content=\"no-store\" /&gt; &lt;link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css\" rel=\"stylesheet\" crossorigin=\"anonymous\"&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://connectors.tableau.com/libs/tableauwdc-2.3.latest.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script src=\"earthquakeWDC.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container container-table\"&gt; &lt;div class=\"row vertical-center-row\"&gt; &lt;div class=\"text-center col-md-4 col-md-offset-4\"&gt; &lt;button type=\"button\" id=\"submitButton\" class=\"btn btn-success\" style=\"margin: 10px;\"&gt;Get Earthquake Data!&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; Let’s run through what the code is doing. Skipping over the standard markup for an HTML page, you’ll notice the following between the head tags: The meta tag prevents your browser from caching the page. The bootstrap.min.css and bootstrap.min.js files are used to simplify styling and formatting. The jquery.min.js file will be used as a helper library by our connector. (For example, the connector uses jQuery to get JSON data.) The tableauwdc-2.3.latest.js file is the main library for the WDC API. The earthquakeWDC.js file is the (not yet created) JavaScript code for our connector. Between the body tags, there is a simple button element that illustrates how users can interact with your connector before getting data. In a later step, you’ll attach an event listener to the button in the JavaScript code. Create the connector object Now that you’ve created a user interface, it’s time to write the JavaScript code for the connector. Create a new file named earthquakeWDC.js and save it in the same directory as the earthquakeWDC.html file. Copy the following code into the file to create the basic structure of the connector: (function () { var myConnector = tableau.makeConnector(); myConnector.getSchema = function (schemaCallback) { }; myConnector.getData = function (table, doneCallback) { }; tableau.registerConnector(myConnector); })(); Some things to note about the code: The code is wrapped in an immediately invoked function expression to create a local scope. The tableau object isn’t defined in our code, but in the WDC library. (It’s assigned to the global scope.) The makeConnector function is a constructor that predefines some methods for our connector object. The getSchema and getData functions are placeholders for now, but will contain the logic for getting the table schema of the data and downloading the data. The registerConnector function validates the connector object before initialization. Add an event listener Remember how we added a button to the HTML page? It’s time to create an event listener that responds to clicking on the button. Copy the following code and paste it directly below the registerConnector function: $(document).ready(function () { $(\"#submitButton\").click(function () { tableau.connectionName = \"USGS Earthquake Feed\"; tableau.submit(); }); }); Here’s what is going on in the code snippet: The jQuery $(document).ready function runs some code when the page loads. An click event listener is added to the button element created earlier. The button is identified by the submitButton id. The tableau.connectionName variable defines what we want to call the connector data source when it is displayed in Tableau. The tableau.submit() function sends the connector object to Tableau for validation. Tip: Not every connector needs a user interface. If you want a connector to run without user input, you can use custom initialization code. For more information, see Custom Initialization and Shutdown Test the connector so far The connector doesn’t do very much so far, but it’s enough that we can run it in the simulator. Note: Have you followed the steps in the Getting Started topic to set up the simulator? This section assumes that you’ve installed dependencies already. Open a command prompt or terminal in the top-level directory for the webdataconnector repository. Run npm start to run the test server. Open a browser and navigate to the following URL: http://localhost:8888/Simulator/index.html In the WDC URL field, enter the path to your WDC relative to the simulator. For example, if you created your WDC in the top-level directory, you might enter: ../earthquakeWDC.html Click the Start Interactive Phase button. The connector page appears in a new window. Click Get Earthquake Data!. The connector page closes. At this point, you might be thinking “Well…did it work?” Let’s add a log message so that you can practice debugging the connector. Add a log message to confirm it is working (sort of) In the earthquakeWDC.js file, copy the following code and replace the empty myConnector.getSchema function: myConnector.getSchema = function (schemaCallback) { tableau.log(\"Hello WDC!\"); }; The tableau.log function allows you to pass messages from your connector back to the simulator. These log messages are then printed with the browser’s built-in console.log() function on the simulator page. Refresh the simulator page in your browser. Open your browser’s developer tools. For example, in Chrome you can press Ctrl+Shift+I. Click Start Interactive Phase. Click Get Earthquake Data!. If all goes well, you should see Hello WDC! in your browser’s console. Define a schema So the connector is working now–sort of. Before you can download data and pass it to Tableau, you need to define how you want to map the data to one or more or tables. This mapping of data is done in the schema. To decide what data you want to map in the schema, you can take a look at the USGS description of the JSON data source: GeoJSON Summary Format. Rather than map all the data available from the data source, this example has selected a focused subset. When you’re done looking at the summary of the JSON data source, copy the following code into the earthquakeWDC.js file and replace the placeholder getSchema function: myConnector.getSchema = function (schemaCallback) { var cols = [{ id: \"id\", dataType: tableau.dataTypeEnum.string }, { id: \"mag\", alias: \"magnitude\", dataType: tableau.dataTypeEnum.float }, { id: \"title\", alias: \"title\", dataType: tableau.dataTypeEnum.string }, { id: \"location\", dataType: tableau.dataTypeEnum.geometry }]; var tableSchema = { id: \"earthquakeFeed\", alias: \"Earthquakes with magnitude greater than 4.5 in the last seven days\", columns: cols }; schemaCallback([tableSchema]); }; Here’s what’s going on in the code: The getSchema function takes a schemaCallback parameter which is defined by the WDC API. The cols variable contains an array of JavaScript objects, where each object defines a single column in our table. In this example, there are columns for magnitude, title, and location. Note that for each column you can specify additional options. For example, the alias defines a friendly name that can appear in Tableau and the columnRole determines whether a field is a measure or a dimension. The id can only contain alphanumeric values (a-z, A-Z, 0-9) and underscore characters (_). The identifiers cannot contain spaces, hyphens, or special characters. For more options, see the API reference. The tableSchema variable defines the schema for a single table and contains a JavaScript object. Here, the value of the columns property is set to the cols array defined earlier. The schemaCallback gets called when the schema is defined. The schemaCallback takes an array of table objects. In this case, there is only table object (the tableSchema object defined above). Note: The API Reference describes the properties that you can define for the table object and for each object in the table columns in more detail. For now, let’s plunge ahead to the exciting part–getting the data! Get the data Once the schema is defined, you can begin getting data and passing it to Tableau. Copy the following code and replace the placeholder getData function: myConnector.getData = function(table, doneCallback) { $.getJSON(\"https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_week.geojson\", function(resp) { var feat = resp.features, tableData = []; // Iterate over the JSON object for (var i = 0, len = feat.length; i &lt; len; i++) { tableData.push({ \"id\": feat[i].id, \"mag\": feat[i].properties.mag, \"title\": feat[i].properties.title, \"location\": feat[i].geometry }); } table.appendRows(tableData); doneCallback(); }); }; Whew! That’s a good-sized chunk of code. Let’s see what’s happening: The getData function takes two parameters: table and doneCallback. The table parameter is an object defined by the WDC to which you can append data. The doneCallback signals to Tableau that you are done getting data. The jQuery $.getJSON function gets earthquake data from the USGS earthquake feed and uses a success handler to store the returned data in a response parameter (resp). (You can open the URL in a browser to see what the JSON data looks like.) The for loop iterates over the features in the JSON object and stores the data that we want in the tableData array. The table.appendRows function appends the tableData array to the table as a JavaScript object. See it in action By now, you’re a pro at running the simulator, so fire it up, load your connector, and click Get Earthquake Data! like before. Now that we have a getSchema function properly defined, you should see the schema displayed in the simulator. The moment you’ve been waiting for is here! Click Fetch Table Data to run your getData function and display the results in a table. Note The location information for an earthquake is returned as a JSON object, which is why you might see object Object displayed in the simulator. Tableau 10.4 added support for geoJSON data, so while the simulator only knows you have some kind of JSON object, Tableau will have no trouble parsing the coordinates from the geometry data. To really see things working, open your connector in Tableau: You did it! Nice work. But this is no time to rest on your laurels–try your connector in Tableau, dig into the Examples directory to see more connectors, or read through the WDC documentation. You might want to start by learning about connectors with multiple tables, incremental refresh, and authentication. See the WDC Multiple Table Tutorial and WDC Node.js Proxy with OAuth Tutorial. Better yet, dive right in and create your own connector!"
                },
            
		
            
                "/webdataconnector/docs/wdc_upgrade.html": {
                    "title": "Upgrading from WDC Version 1.x",
                    "content": "If you have built connectors using WDC version 1.x you can continue to use those connectors in Tableau, up through Tableau 2019.1. See WDC Versions for information about compatibility. However, you cannot turn a version 1.x connector into a version 2.x connector by just linking to version 2.x of the Tableau WDC library. The connector will not work unless you also update the connector to use code changes introduced in version 2.x of the API. In this section Why should you upgrade? You should considering upgrading your connectors to version 2.x to have access to all the great new features that have been introduced for WDC in Tableau 10.0 and later. You might want to keep your version 1.x connectors if you need to support earlier versions of Tableau. In version 2.x you can: Include multiple tables of data. Signal that you are done gathering data with a single callback, and you can add data that you gather directly to a table object created by Tableau. Previously, there was no way to signal that you were done gathering data. As a result, the WDC API repeatedly ran your getTableData function so that you could pass data to Tableau through a callback parameter. Use the locale API to get the language currently set by the user in Tableau. Specify how you want to join tables (standard connections) in Tableau Desktop. Use join filtering to filter the data from one table based on the data from another. Connect directly to spatial data. Using the new geometry value in the tableau.dataType enum, you can send GeoJSON objects directly back to Tableau. Lifecycle and phase differences between version 1.x and version 2.x To support the new features, changes have been made to the API. For example, to support multiple tables, there is now a getSchema() function that has a callback function for reporting the tables contained in the WDC. The getTableData() function was changed to getData() and it now takes a table object as a parameter. Review the following list and the samples to better understand the changes. In version 1.x: A connector loads and runs its interactive phase, then calls tableau.submit(). In the data gathering phase, Tableau calls connector.getColumnHeaders(), which defines the schema for a single table. The getColumnHeaders() function finishes by calling a predefined callback. Tableau calls connector.getTableData(), which passes data to Tableau by means of a parameter on the predefined tableau.dataCallback() function. Step 3 is repeated until tableau.dataCallback() passes a flag to Tableau to signal that there is no more data. In version 2.x: A connector loads and runs its interactive phase, then calls tableau.submit(). In the data gathering phase, Tableau calls connector.getSchema(), which defines the schema for one or more tables. The connector calls a predefined callback to signal that it is done defining the table schema. Tableau calls connector.getData() with a table object parameter and a callback parameter. The getData() function appends data to the table object using the object’s built-in table.appendRows() function. The getData() function is called once for each table defined in the schema. When the getData() function is done gathering data, it calls the doneCallback() that it was passed as a parameter. Changes to column and table identifiers In WDC version 2.x, the column and table identifiers (columnId and tableId) can only contain alphanumeric (a-z, A-Z, 0-9) and underscore characters (_). The identifiers must match the regular expression: ^[a-zA-Z0-9_]*$. The identifiers cannot contain spaces, hyphens, or special characters. In WDC version 1.x, the string values containing spaces were allowed to pass through. Test your connector with the WDC simulator As always, it is good practice to test your connector in the WDC version 2.x simulator to make sure you are getting the data that you expect. See Debugging in the Simulator and Tableau."
                },
            
		
            
                "/webdataconnector/docs/wdc_use_in_server.html": {
                    "title": "Use a WDC in Tableau Server",
                    "content": "You can use your web data connector (WDC) on Tableau Server as you would any other data source. You can publish the web data connector as a data source, or you can publish a workbook that embeds your connector as the data source. When you use a web data connector, Tableau creates an extract of the data. You can refresh the extract in Tableau Desktop. However, to be able to refresh the extract on Tableau Server, there are a couple of other considerations. If your web data connector requires authentication, you need to embed the credentials when you publish the data source or workbook. This is because the refresh can occur on a schedule or in some other background context, and the server cannot prompt for credentials. You should store credentials in tableau.username and tableau.password as these fields are encrypted. Do not use tableau.connectionData for sensitive information as this field is stored in plain text. You need to ensure that your web data connector is added to the safe list, and also ensure that the secondary safe list includes the domains that the connector can send requests to and receive requests from (external JavaScript libraries, local files, REST APIs). Because a WDC contains JavaScript and typically connects to other sites, you need to work with the Tableau Server administrator to test and verify the connector is safe to use. After verifying the WDC, the Tableau Server administrator can use the Tableau Services Manager (TSM) command line interface (CLI) to allow the WDC on the Tableau Server. For example, a Tableau Server administrator might use the following TSM command to add the sample USGS EarthQuake data connector to the safe list. This command also adds a secondary safe list that includes the domains of the libraries and sources that the WDC makes use of. You can’t use wildcards in the primary URL (--url), but you can use wildcards (.*) in the secondary safe list (--secondary). tsm data-access web-data-connectors add --name \"USGS Earthquakes\" --url https://tableau.github.io:443/webdataconnector/Examples/html/earthquakeUSGS.html --secondary https://tableau.github.io/.*,https://earthquake.usgs.gov/.*,https://maxcdn.bootstrapcdn.com/.*,https://ajax.googleapis.com/.*,https://connectors.tableau.com/.* For security, consider using HTTPS protocol for the connector and all external libraries that your web data connector uses. For more information, see Web Data Connectors in Tableau Server and Testing and Vetting Web Data Connectors in the Tableau Server Help."
                },
            
		
            
                "/webdataconnector/docs/wdc_use_in_tableau.html": {
                    "title": "Use a WDC in Tableau Desktop",
                    "content": "To use a WDC in Tableau Desktop, complete the following steps: On the start page, in the Connect pane, click More Servers… &gt; Web Data Connector. Enter the URL of a WDC and press Enter. Important: Make sure that you enter the URL of a WDC, and not the URL of the data that you’re trying to connect to. For example, if you want to connect to FaceBook data, you might enter www.example.com/myFacebookWDC.html. Tableau loads the WDC page where you can enter any input required by your WDC. Tableau calls your WDC code, downloads data, and displays it in the Data Source pane. For more information about using a WDC in Tableau Desktop, see Web Data Connector."
                },
            
		
            
                "/webdataconnector/docs/wdc_webengine.html": {
                    "title": "Troubleshoot WDC WebEngine Issues in Tableau 2019.4 and later",
                    "content": "Prior to Tableau 2019.4, Web Data Connectors used an internal browser in Tableau called Qt WebKit. In Tableau 2019.4 and later, Web Data Connectors use Qt WebEngine, a Chromium-based browser. The Qt WebEngine is a significant upgrade over the previous internal browser and WDC developers will benefit from being able to use modern JavaScript tools and practices that improve the user interface and user interactions. The new browser provides better support for HTML5 and allows developers to use modern debugging tools and the Chrome DevTools for debugging WDC code. However, because of the internal browser change, some customers might experience problems using their existing connectors in Tableau 2019.4 and later. This topic describes some of these issues and provides possible solutions. Before you begin Before diagnosing problems, be sure to launch Tableau Desktop with debugging enabled (--remote-debugging-port=9000 option) and check for console messages. For more information, see Debugging in the Simulator and the Debugger. The console messages will also be written to the Tableau log file (regular log file on Tableau Desktop; the tabprotosrv logs on Tableau Server). To open the WDC in the debugger, open a new Chrome browser instance and set the URL to localhost:9000. Select the WDC in the browser and begin debugging. For more information, see Debugging a WDC in Tableau Desktop 2019.4 (and later). Although the extract is created successfully, no data is inserted into it Details: In Tableau 2019.4 and later, Web Data Connectors use Qt WebEngine as the internal browser. The version of the Qt WebEngine we currently use has a limitation in its data communication channel of approximately 128MB. This limitation restricts the amount of data that you can append to the extract at a time. In addition, the actual amount of data you can append could appear to be much smaller than 128MB, as there is often some additional information or metadata associated with the data. If your WDC appends more data than can be transmitted, the WDC is created and initialized but no data is added. For information on the Qt limitation, see QTBUG-47629 Resolution: Depending upon the size of your data, it’s a best practice to insert data into the table in amounts smaller than 128MB (accounting for the additional metadata). For more information and for example code showing one way of breaking up the data into smaller chunks, see Get Data - Best Practices. Starting Tableau using tableau.exe -DebugWDC doesn’t work Resolution: Starting with Tableau 2019.4, you can use the Chrome DevTools to debug WDCs. You no longer use the built-in debugger that was available in earlier versions of Tableau (before Tableau 2019.4). See Debugging a WDC in Tableau Desktop 2019.4 (and later). Debugging connection was closed (when refreshing the extract) Resolution: When performing data refreshes, you might find it challenging to stay connected to a remote debugging session using the Chrome Developer Tools. This is because Tableau disconnects the debugging connection before performing a refresh of an extract, causing the debugging session to be reset, which requires that you open a new instance of the Chrome Developer Tools to make the new connection. The recommended way to debug the getSchema and getData methods is to use the Tableau Data pane and then set breakpoints in the Developer Tools. Start Tableau (with remote debugging enabled and connect to your WDC (see Debugging a WDC in Tableau Desktop 2019.4 (and later)). In the Data pane, drag out a table to the join area (if it is not there already). Connect the Chrome Developer Tools to your WDC. Set your breakpoints on the getSchema and getData methods, and then click Update Now. The WDC library (wdclib) version not supported Details: Starting with Tableau 2019.4, Tableau no longer supports older versions of wdclib (the WDC library). This includes WDC versions 1.0, 1.1, 2.0.0, and 2.0.1. For more information, see WDC Versions. Resolution: WDCs that use an old version of wdclib need to upgrade to the latest version. If you are a developer of a Web Data Connector, refer to the migration guide for the steps to upgrade from version 1.x, see Upgrading from WDC Version 1.x. If you are already using a 2.x library, you should be able to just upgrade to a newer version of the library (for example, wdclib-2.3.latest.js). For more information, see WDC Versions. JavaScript console errors, such as not a valid WDC or tableau.XXX not a valid object Details: In Tableau 2019.3 and earlier, Web Data Connectors use QT WebKit as the internal browser and are initialized in a synchronous manner, which prevents the WDC code from executing until all bootstrapping code is complete. With QT WebEngine, the Chromium-based internal browser used in Tableau 2019.4 and later, it is not possible to make this guarantee. If your WDC attempts to use the window.tableau object before the init method is called, problems might occur as the API is not fully initialized. Resolution: For many WDCs, simply upgrading to the latest wdclib library will help. We have released patched versions of 2.1.x, 2.2.x, and 2.3.x to accommodate this. Make sure your WDC is using the latest version of one of those libraries: wdclib-2.1.latest.js, wdclib-2.2.latest.js, or wdclib-2.3.latest.js. You should also be aware that the WDC can’t reliably use the window.tableau object until after the WDC has been initialized. For example, it is illegal to use window.tableau.log before the WDC has been initialized. There is no resolution to this latter issue; WDCs should simply not do this. Mixed-mode HTTP(S) errors Details: In Tableau 2019.3 and earlier, which use the QT WebKit internal browser, mixed-mode HTTP and HTTPS calls are legal. For example, in earlier versions of Tableau, a WDC is able to make an AJAX request from an HTTPS host to an HTTP host, or can make HTTP requests for images, scripts, or other HTML elements from an HTTPS web page. In Tableau 2019.4 and later, the Chromium-based QT WebEngine browser reports errors when the WDC attempts mixed-mode calls. Resolution: Always use HTTPS endpoints. Do not use mixed-mode. Cookies are not preserved between instances of the WDC connection dialog Details: In Tableau 2019.3 and earlier, cookies might have been preserved under Qt WebKit WDC connection dialog instances. This was never intentionally supported and does not work in Tableau 2019.4 and later, which use the Chromium-based Qt WebEngine browser. Resolution: Don’t rely on cookies. Use tableau.connectionData to pass data and expect users may need to re-authenticate if you don’t preserve session data."
                }
            
		
		};
	</script>

    <script src="/webdataconnector/assets/js/lunr.min.js"></script>
    <script src="/webdataconnector/assets/js/search.js"></script>
</head>

<body>
    <div class="container">
        <header class="site-header">
  <div class="wrapper">
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand navbar-brand-logo" href="/webdataconnector/#">Tableau Web Data Connector</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="/webdataconnector/docs/index.html">Docs</a></li>
            <li><a href="/webdataconnector/docs/api_ref.html">API Reference</a></li>
            <li><a href="/webdataconnector/community/">Community Connectors</a></li>
            <li><a target="_blank" href="https://community.tableau.com/s/topic/0TO4T000000QFBJWA4/web-data-connector">Forum</a></li>
            <li><a href="/webdataconnector/news/">What's New?</a></li>
            
          </ul>
          <ul class="nav navbar-nav navbar-right">
            <li class="tableauIcon"><a target="_blank" href="http://tableau.com"><img src="/webdataconnector/assets/logo.png" alt="Tableau Developers" class="logo" /></a></li>
            <li><a target="_blank" href="https://github.com/tableau/webdataconnector"><span class="icon icon--github" title="WDC on GitHub" alt="WDC on GitHub"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span></a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>
  </div>
</header>

        <div class="well docs-menu col-xs-12 col-sm-4 col-md-3">
    <div class="search-container form-group has-feedback">
    <form id="docs-search">
        <input type="search" id="search-input" class="custom-search form-control" placeholder="Search the docs..." search-url="/webdataconnector/docs/search.html">
        <span class="glyphicon glyphicon-search form-control-feedback"></span>
    </form>
</div>


    <ul class="nav nav-list">
        <li class="nav-header">Overview</li>
        <li>
            <a href="/webdataconnector/docs/index.html">Get Started</a>
        </li>
        <li>
            <a href="/webdataconnector/docs/wdc_tutorial.html">Tutorial</a>
        </li>
        <li>
            <a href="/webdataconnector/docs/wdc_use_in_tableau.html">Use a WDC in Tableau Desktop</a>
        </li>
		<li>
            <a href="/webdataconnector/docs/wdc_use_in_server.html">Use a WDC in Tableau Server</a>
        </li>

        <li class="nav-header">Basic Concepts</li>
        <li>
            <a href="/webdataconnector/docs/wdc_phases.html">Lifecycle and Phases</a>
        </li>
        <li>
            <a href="/webdataconnector/docs/wdc_library_versions.html">API Versions</a>
        </li>
        <li>
            <a href="/webdataconnector/docs/wdc_samples.html">Samples</a>
        </li>
        <li>
            <a href="/webdataconnector/docs/wdc_debugging.html">Debugging in the Simulator and Tableau</a>
        </li>
        <li>
            <a href="/webdataconnector/docs/wdc_hosting_and_submissions.html">Hosting and Submitting to Community Portal</a>
        </li>

        <li class="nav-header">Advanced Concepts</li>
        <li>
            <a href="/webdataconnector/docs/wdc_multi_table_tutorial.html">Multiple Tables Tutorial</a>
        </li>
        <li>
            <a href="/webdataconnector/docs/wdc_oauth_tutorial.html">Node.js Proxy with OAuth Tutorial</a>
        </li>
        <li>
            <a href="/webdataconnector/docs/wdc_standard_connections.html">Standard Connections</a>
        </li>
        <li>
            <a href="/webdataconnector/docs/wdc_join_filtering.html">Join Filtering</a>
        </li>
        <li>
            <a href="/webdataconnector/docs/wdc_custom_init_and_shutdown.html">Custom Initialization and Shutdown</a>
        </li>
        <li>
            <a href="/webdataconnector/docs/wdc_get_data.html">Get Data: Best Practices</a>
        </li>
        <li>
            <a href="/webdataconnector/docs/wdc_incremental_refresh.html">Incremental Refresh</a>
        </li>
        <li>
            <a href="/webdataconnector/docs/wdc_authentication.html">Authentication</a>
        </li>
        <li>
            <a href="/webdataconnector/docs/wdc_cors.html">Working with CORS</a>
        </li>

        <li class="nav-header">Reference</li>
        <li>
            <a href="/webdataconnector/docs/wdc_resources.html">Resources</a>
        </li>
        <li>
            <a href="/webdataconnector/docs/wdc_ref_date_formats.html">Supported Date Formats</a>
        </li>
        <li>
            <a href="/webdataconnector/docs/wdc_faq.html">FAQ</a>
        </li>
		    <li>
		    <a href="/webdataconnector/docs/wdc_upgrade.html">Upgrading from WDC Version 1.x</a>
        </li>
        <li>
		    <a href="/webdataconnector/docs/wdc_webengine.html">Troubleshoot WDC WebEngine Issues</a>
		   </li>
           <li>
		    <a href="/webdataconnector/docs/wdc_about.html">About Tableau Help</a>
		   </li>
    </ul>
</div>


        <div class="content .col-xs-12 .col-sm-8 .col-md-9">
            <h1 id="searchHeading"></h1>
            <br />
            <div id="searchResultsContainer">
                <p>Loading search results...</p>
            </div>

            <!-- Footer -->
<footer>
    <div class="row">
            <hr class="footer-hr">
            <p>This site is open source. Suggestions and pull requests are welcome on our <a href="https://github.com/tableau/webdataconnector">GitHub page</a>.</p>
            <p><a href="https://www.tableau.com/en-us/legal" class="aLegal">LEGAL</a> <a href="https://www.salesforce.com/company/privacy/" class="aLegal">PRIVACY</a> &copy; 2003&ndash;<script>document.write(new Date().getFullYear())</script> TABLEAU SOFTWARE LLC. ALL RIGHTS RESERVED</p>
            <sub>Documentation last generated on: 2023-03-07 13:27:13 -0800</sub>
    </div>
</footer>

        </div>
    </div>
</body>
</html>
